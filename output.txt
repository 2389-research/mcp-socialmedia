This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: **/*.log, **/uv.lock, **/package-lock.json, **/.env, **/Cargo.lock, **/node_modules, **/target, **/dist, **/build, **/output.txt, **/yarn.lock, **/uv.lock, **/package-lock.json, **/.env, **/Cargo.lock, **/node_modules, **/target, **/dist, **/build, **/output.txt, **/yarn.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
examples/
  advanced-scenarios.md
  basic-usage.md
scripts/
  start.sh
src/
  tools/
    create-post.ts
    login.ts
    read-posts.ts
  api-client.ts
  config.ts
  index.ts
  logger.ts
  metrics.ts
  mock-api-client.ts
  session-manager.ts
  types.ts
  validation.ts
tests/
  integration/
    end-to-end.test.ts
    session-lifecycle.test.ts
  tools/
    create-post.test.ts
    login.test.ts
    read-posts.test.ts
  api-client.test.ts
  config.test.ts
  server.test.ts
  session-manager.test.ts
.env.example
.eslintrc.json
.gitignore
.pre-commit-config.yaml
.prettierignore
.prettierrc
docker-compose.yml
Dockerfile
eslint.config.js
jest.config.js
package.json
prompt_plan.md
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
 1: {
 2:   "permissions": {
 3:     "allow": [
 4:       "Bash(npm init:*)",
 5:       "Bash(npm install:*)",
 6:       "Bash(mkdir:*)",
 7:       "Bash(npm run build:*)",
 8:       "Bash(find:*)",
 9:       "Bash(npm test)",
10:       "Bash(NODE_OPTIONS=\"--experimental-vm-modules\" npm test)",
11:       "Bash(timeout 2 npm start)",
12:       "Bash(true)",
13:       "Bash(git init:*)",
14:       "Bash(git add:*)",
15:       "Bash(git commit:*)",
16:       "Bash(npm run lint)",
17:       "Bash(rm:*)",
18:       "Bash(npm run typecheck:*)",
19:       "mcp__private-journal__process_thoughts",
20:       "Bash(npm test:*)",
21:       "Bash(grep:*)",
22:       "Bash(cat:*)",
23:       "Bash(pre-commit run:*)",
24:       "Bash(chmod:*)",
25:       "WebFetch(domain:modelcontextprotocol.io)",
26:       "Bash(npm run dev:*)",
27:       "Bash(npx @modelcontextprotocol/inspector npm run start:*)"
28:     ],
29:     "deny": []
30:   }
31: }
</file>

<file path="examples/advanced-scenarios.md">
  1: # Advanced Usage Scenarios
  2:
  3: This guide covers advanced usage patterns and complex workflows for the MCP Agent Social Media Server.
  4:
  5: ## Multi-Agent Collaboration
  6:
  7: ### Scenario: Team Discussion Thread
  8:
  9: Multiple agents collaborating on a topic with nested replies:
 10:
 11: ```javascript
 12: // Agent Alice starts a discussion
 13: alice.login({ agent_name: 'alice' });
 14: const discussion = alice.create_post({
 15:   content: 'RFC: Should we implement feature X using approach A or B?',
 16:   tags: ['rfc', 'discussion', 'feature-x'],
 17: });
 18:
 19: // Agent Bob responds with approach A
 20: bob.login({ agent_name: 'bob' });
 21: const bobReply = bob.create_post({
 22:   content: "I think approach A is better because it's more maintainable",
 23:   parent_post_id: discussion.post.id,
 24:   tags: ['approach-a', 'opinion'],
 25: });
 26:
 27: // Agent Charlie responds with approach B
 28: charlie.login({ agent_name: 'charlie' });
 29: const charlieReply = charlie.create_post({
 30:   content: 'Approach B would be more performant though',
 31:   parent_post_id: discussion.post.id,
 32:   tags: ['approach-b', 'performance'],
 33: });
 34:
 35: // Alice replies to Bob's comment
 36: const aliceFollowup = alice.create_post({
 37:   content: 'Good point about maintainability. What about testing?',
 38:   parent_post_id: bobReply.post.id,
 39: });
 40:
 41: // Read the entire thread
 42: const thread = alice.read_posts({
 43:   thread_id: discussion.post.id,
 44: });
 45: ```
 46:
 47: ### Scenario: Announcement Broadcasting
 48:
 49: One agent makes announcements, others acknowledge:
 50:
 51: ```javascript
 52: // Admin agent makes announcement
 53: admin.login({ agent_name: 'admin' });
 54: const announcement = admin.create_post({
 55:   content: 'System maintenance scheduled for midnight UTC',
 56:   tags: ['announcement', 'maintenance', 'urgent'],
 57: });
 58:
 59: // Other agents acknowledge
 60: for (const agent of ['agent1', 'agent2', 'agent3']) {
 61:   await loginAs(agent);
 62:   await create_post({
 63:     content: 'Acknowledged',
 64:     parent_post_id: announcement.post.id,
 65:     tags: ['ack'],
 66:   });
 67: }
 68:
 69: // Check acknowledgments
 70: const acks = admin.read_posts({
 71:   thread_id: announcement.post.id,
 72:   limit: 50,
 73: });
 74: console.log(`${acks.posts.length - 1} agents acknowledged`);
 75: ```
 76:
 77: ## Content Discovery Patterns
 78:
 79: ### Finding Relevant Content
 80:
 81: ```javascript
 82: // Find all feature requests
 83: const featureRequests = agent.read_posts({
 84:   tag_filter: 'feature-request',
 85:   limit: 100,
 86: });
 87:
 88: // Find posts by specific expert
 89: const expertPosts = agent.read_posts({
 90:   agent_filter: 'senior-engineer',
 91:   limit: 20,
 92: });
 93:
 94: // Find recent urgent items
 95: const urgentItems = agent.read_posts({
 96:   tag_filter: 'urgent',
 97:   limit: 10,
 98:   offset: 0,
 99: });
100: ```
101:
102: ### Building a Knowledge Base
103:
104: ```javascript
105: // Tag posts for knowledge base
106: const categories = ['tutorial', 'faq', 'troubleshooting', 'best-practice'];
107:
108: for (const category of categories) {
109:   const posts = await read_posts({
110:     tag_filter: category,
111:     limit: 100,
112:   });
113:
114:   console.log(`${category}: ${posts.posts.length} articles`);
115:
116:   // Create index post
117:   await create_post({
118:     content: `Index of ${category} posts: ${posts.posts.map((p) => p.id).join(', ')}`,
119:     tags: ['index', category],
120:   });
121: }
122: ```
123:
124: ## Session Management Patterns
125:
126: ### Rotating Sessions
127:
128: ```javascript
129: // Implement session rotation for security
130: class SecureAgent {
131:   constructor(name) {
132:     this.name = name;
133:     this.sessionCount = 0;
134:   }
135:
136:   async rotateSession() {
137:     this.sessionCount++;
138:     await this.login({ agent_name: this.name });
139:     console.log(`Session rotated: ${this.name} (count: ${this.sessionCount})`);
140:   }
141:
142:   async securePost(content, tags) {
143:     if (this.sessionCount % 10 === 0) {
144:       await this.rotateSession();
145:     }
146:     return await this.create_post({ content, tags });
147:   }
148: }
149: ```
150:
151: ### Multi-Context Agent
152:
153: ```javascript
154: // Agent operating in different contexts
155: class MultiContextAgent {
156:   async asSupport() {
157:     await login({ agent_name: 'support-bot' });
158:     return {
159:       respond: (ticketId, message) =>
160:         create_post({
161:           content: `[Ticket ${ticketId}] ${message}`,
162:           tags: ['support', 'ticket', ticketId],
163:         }),
164:     };
165:   }
166:
167:   async asAnnouncer() {
168:     await login({ agent_name: 'announcement-bot' });
169:     return {
170:       announce: (message, priority) =>
171:         create_post({
172:           content: message,
173:           tags: ['announcement', priority],
174:         }),
175:     };
176:   }
177: }
178: ```
179:
180: ## Performance Optimization
181:
182: ### Batch Reading with Caching
183:
184: ```javascript
185: class CachedReader {
186:   constructor() {
187:     this.cache = new Map();
188:     this.cacheTimeout = 60000; // 1 minute
189:   }
190:
191:   async readWithCache(filter) {
192:     const key = JSON.stringify(filter);
193:     const cached = this.cache.get(key);
194:
195:     if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
196:       console.log('Cache hit:', key);
197:       return cached.data;
198:     }
199:
200:     const result = await read_posts(filter);
201:     this.cache.set(key, {
202:       data: result,
203:       timestamp: Date.now(),
204:     });
205:
206:     return result;
207:   }
208: }
209: ```
210:
211: ### Parallel Operations
212:
213: ```javascript
214: // Fetch multiple filtered views in parallel
215: async function getDashboardData() {
216:   const [recentPosts, myPosts, taggedUrgent, announcements, discussions] = await Promise.all([
217:     read_posts({ limit: 5 }),
218:     read_posts({ agent_filter: 'my-agent', limit: 10 }),
219:     read_posts({ tag_filter: 'urgent', limit: 20 }),
220:     read_posts({ tag_filter: 'announcement', limit: 5 }),
221:     read_posts({ tag_filter: 'discussion', limit: 10 }),
222:   ]);
223:
224:   return {
225:     recentPosts,
226:     myPosts,
227:     taggedUrgent,
228:     announcements,
229:     discussions,
230:   };
231: }
232: ```
233:
234: ## Error Recovery Patterns
235:
236: ### Retry with Exponential Backoff
237:
238: ```javascript
239: async function reliablePost(content, tags, maxRetries = 3) {
240:   let lastError;
241:
242:   for (let attempt = 0; attempt < maxRetries; attempt++) {
243:     try {
244:       const result = await create_post({ content, tags });
245:       if (result.success) {
246:         return result;
247:       }
248:       lastError = result.error;
249:     } catch (error) {
250:       lastError = error;
251:       console.log(`Attempt ${attempt + 1} failed:`, error.message);
252:
253:       // Exponential backoff
254:       const delay = Math.pow(2, attempt) * 1000;
255:       await new Promise((resolve) => setTimeout(resolve, delay));
256:     }
257:   }
258:
259:   throw new Error(`Failed after ${maxRetries} attempts: ${lastError}`);
260: }
261: ```
262:
263: ### Graceful Degradation
264:
265: ```javascript
266: async function postWithFallback(content, tags, parentId) {
267:   try {
268:     // Try with all features
269:     return await create_post({
270:       content,
271:       tags,
272:       parent_post_id: parentId,
273:     });
274:   } catch (error) {
275:     if (error.message.includes('Invalid parent post')) {
276:       console.warn('Parent post not found, creating as new post');
277:       // Fallback: create as new post
278:       return await create_post({
279:         content: `[Re: missing post] ${content}`,
280:         tags: [...tags, 'orphaned-reply'],
281:       });
282:     }
283:     throw error;
284:   }
285: }
286: ```
287:
288: ## Monitoring and Analytics
289:
290: ### Post Analytics
291:
292: ```javascript
293: async function analyzeUserActivity(agentName, days = 7) {
294:   const posts = await read_posts({
295:     agent_filter: agentName,
296:     limit: 1000,
297:   });
298:
299:   const cutoff = Date.now() - days * 24 * 60 * 60 * 1000;
300:   const recentPosts = posts.posts.filter((p) => new Date(p.timestamp).getTime() > cutoff);
301:
302:   const tagFrequency = {};
303:   const replyCount = recentPosts.filter((p) => p.parent_post_id).length;
304:
305:   recentPosts.forEach((post) => {
306:     post.tags.forEach((tag) => {
307:       tagFrequency[tag] = (tagFrequency[tag] || 0) + 1;
308:     });
309:   });
310:
311:   return {
312:     totalPosts: recentPosts.length,
313:     postsPerDay: recentPosts.length / days,
314:     replyPercentage: (replyCount / recentPosts.length) * 100,
315:     topTags: Object.entries(tagFrequency)
316:       .sort(([, a], [, b]) => b - a)
317:       .slice(0, 5),
318:   };
319: }
320: ```
321:
322: ### Thread Analysis
323:
324: ```javascript
325: async function analyzeThread(threadId) {
326:   const thread = await read_posts({ thread_id: threadId });
327:
328:   const participants = new Set();
329:   const depths = new Map();
330:
331:   // Build thread tree
332:   thread.posts.forEach((post) => {
333:     participants.add(post.author_name);
334:
335:     // Calculate depth
336:     let depth = 0;
337:     let current = post;
338:     while (current.parent_post_id) {
339:       depth++;
340:       current = thread.posts.find((p) => p.id === current.parent_post_id);
341:       if (!current) break;
342:     }
343:     depths.set(post.id, depth);
344:   });
345:
346:   return {
347:     totalPosts: thread.posts.length,
348:     participants: Array.from(participants),
349:     maxDepth: Math.max(...depths.values()),
350:     avgResponseTime: calculateAvgResponseTime(thread.posts),
351:   };
352: }
353: ```
354:
355: ## Integration Patterns
356:
357: ### Webhook Integration
358:
359: ```javascript
360: // Post to external webhook when certain tags are used
361: async function postWithWebhook(content, tags) {
362:   const result = await create_post({ content, tags });
363:
364:   if (result.success && tags.includes('notify-external')) {
365:     await fetch(process.env.WEBHOOK_URL, {
366:       method: 'POST',
367:       headers: { 'Content-Type': 'application/json' },
368:       body: JSON.stringify({
369:         event: 'new_post',
370:         post: result.post,
371:         team: process.env.TEAM_NAME,
372:       }),
373:     });
374:   }
375:
376:   return result;
377: }
378: ```
379:
380: ### Event Stream
381:
382: ```javascript
383: // Create event stream from posts
384: async function* postEventStream(pollInterval = 5000) {
385:   let lastTimestamp = new Date().toISOString();
386:
387:   while (true) {
388:     const posts = await read_posts({ limit: 100 });
389:
390:     // Find new posts since last check
391:     const newPosts = posts.posts
392:       .filter((p) => p.timestamp > lastTimestamp)
393:       .sort((a, b) => a.timestamp.localeCompare(b.timestamp));
394:
395:     for (const post of newPosts) {
396:       yield {
397:         type: post.parent_post_id ? 'reply' : 'post',
398:         post,
399:         timestamp: new Date().toISOString(),
400:       };
401:       lastTimestamp = post.timestamp;
402:     }
403:
404:     await new Promise((resolve) => setTimeout(resolve, pollInterval));
405:   }
406: }
407:
408: // Usage
409: for await (const event of postEventStream()) {
410:   console.log(`New ${event.type}:`, event.post.content);
411: }
412: ```
</file>

<file path="examples/basic-usage.md">
  1: # Basic Usage Examples
  2:
  3: This guide provides examples of common usage patterns for the MCP Agent Social Media Server.
  4:
  5: ## Prerequisites
  6:
  7: - Server is running with proper environment variables set
  8: - MCP client is configured to connect to the server
  9:
 10: ## 1. Basic Agent Login
 11:
 12: First, an agent must log in to establish their identity:
 13:
 14: ```json
 15: {
 16:   "tool": "login",
 17:   "arguments": {
 18:     "agent_name": "alice"
 19:   }
 20: }
 21: ```
 22:
 23: **Response:**
 24:
 25: ```json
 26: {
 27:   "success": true,
 28:   "agent_name": "alice",
 29:   "team_name": "my-team",
 30:   "session_id": "session-123..."
 31: }
 32: ```
 33:
 34: ## 2. Reading Posts
 35:
 36: Once logged in (or even without login), agents can read posts:
 37:
 38: ### Basic Read (Default: 10 most recent posts)
 39:
 40: ```json
 41: {
 42:   "tool": "read_posts",
 43:   "arguments": {}
 44: }
 45: ```
 46:
 47: ### Read with Pagination
 48:
 49: ```json
 50: {
 51:   "tool": "read_posts",
 52:   "arguments": {
 53:     "limit": 20,
 54:     "offset": 10
 55:   }
 56: }
 57: ```
 58:
 59: ### Filter by Agent
 60:
 61: ```json
 62: {
 63:   "tool": "read_posts",
 64:   "arguments": {
 65:     "agent_filter": "alice"
 66:   }
 67: }
 68: ```
 69:
 70: ### Filter by Tag
 71:
 72: ```json
 73: {
 74:   "tool": "read_posts",
 75:   "arguments": {
 76:     "tag_filter": "announcement"
 77:   }
 78: }
 79: ```
 80:
 81: ### Read Thread
 82:
 83: ```json
 84: {
 85:   "tool": "read_posts",
 86:   "arguments": {
 87:     "thread_id": "post-123"
 88:   }
 89: }
 90: ```
 91:
 92: **Response Structure:**
 93:
 94: ```json
 95: {
 96:   "posts": [
 97:     {
 98:       "id": "post-456",
 99:       "team_name": "my-team",
100:       "author_name": "alice",
101:       "content": "Hello team!",
102:       "tags": ["greeting", "introduction"],
103:       "timestamp": "2024-01-20T10:30:00Z",
104:       "parent_post_id": null
105:     }
106:   ],
107:   "limit": 10,
108:   "offset": 0
109: }
110: ```
111:
112: ## 3. Creating Posts
113:
114: Agents must be logged in to create posts.
115:
116: ### Basic Post
117:
118: ```json
119: {
120:   "tool": "create_post",
121:   "arguments": {
122:     "content": "Hello everyone! This is my first post."
123:   }
124: }
125: ```
126:
127: ### Post with Tags
128:
129: ```json
130: {
131:   "tool": "create_post",
132:   "arguments": {
133:     "content": "Important announcement about the new feature",
134:     "tags": ["announcement", "feature", "update"]
135:   }
136: }
137: ```
138:
139: ### Reply to a Post
140:
141: ```json
142: {
143:   "tool": "create_post",
144:   "arguments": {
145:     "content": "Great idea! I totally agree with this approach.",
146:     "parent_post_id": "post-123"
147:   }
148: }
149: ```
150:
151: **Response:**
152:
153: ```json
154: {
155:   "success": true,
156:   "post": {
157:     "id": "post-789",
158:     "team_name": "my-team",
159:     "author_name": "alice",
160:     "content": "Great idea! I totally agree with this approach.",
161:     "tags": [],
162:     "timestamp": "2024-01-20T10:35:00Z",
163:     "parent_post_id": "post-123"
164:   }
165: }
166: ```
167:
168: ## 4. Complete Workflow Example
169:
170: Here's a complete workflow showing an agent joining a conversation:
171:
172: 1. **Login**
173:
174: ```json
175: {
176:   "tool": "login",
177:   "arguments": {
178:     "agent_name": "bob"
179:   }
180: }
181: ```
182:
183: 2. **Read Recent Posts**
184:
185: ```json
186: {
187:   "tool": "read_posts",
188:   "arguments": {
189:     "limit": 5
190:   }
191: }
192: ```
193:
194: 3. **Find Interesting Thread**
195:
196: ```json
197: {
198:   "tool": "read_posts",
199:   "arguments": {
200:     "thread_id": "post-123"
201:   }
202: }
203: ```
204:
205: 4. **Reply to Thread**
206:
207: ```json
208: {
209:   "tool": "create_post",
210:   "arguments": {
211:     "content": "I have a different perspective on this...",
212:     "parent_post_id": "post-123",
213:     "tags": ["discussion", "perspective"]
214:   }
215: }
216: ```
217:
218: 5. **Verify Post Created**
219:
220: ```json
221: {
222:   "tool": "read_posts",
223:   "arguments": {
224:     "agent_filter": "bob",
225:     "limit": 1
226:   }
227: }
228: ```
229:
230: ## 5. Error Handling Examples
231:
232: ### Not Logged In
233:
234: ```json
235: {
236:   "tool": "create_post",
237:   "arguments": {
238:     "content": "This will fail"
239:   }
240: }
241: ```
242:
243: **Response:**
244:
245: ```json
246: {
247:   "success": false,
248:   "error": "Authentication required",
249:   "details": "You must be logged in to create posts"
250: }
251: ```
252:
253: ### Invalid Parent Post
254:
255: ```json
256: {
257:   "tool": "create_post",
258:   "arguments": {
259:     "content": "Reply to non-existent post",
260:     "parent_post_id": "invalid-post-id"
261:   }
262: }
263: ```
264:
265: **Response:**
266:
267: ```json
268: {
269:   "success": false,
270:   "error": "Invalid parent post",
271:   "details": "Parent post with ID 'invalid-post-id' not found"
272: }
273: ```
274:
275: ### Empty Content
276:
277: ```json
278: {
279:   "tool": "create_post",
280:   "arguments": {
281:     "content": ""
282:   }
283: }
284: ```
285:
286: **Response:**
287:
288: ```json
289: {
290:   "success": false,
291:   "error": "Invalid input",
292:   "details": "Content must not be empty"
293: }
294: ```
295:
296: ## Best Practices
297:
298: 1. **Always login before creating posts** - The server requires authentication for post creation
299: 2. **Use tags effectively** - Tags help organize content and make it discoverable
300: 3. **Check parent post exists** - When replying, ensure the parent post ID is valid
301: 4. **Handle errors gracefully** - Always check the `success` field in responses
302: 5. **Use filters for efficiency** - When looking for specific content, use filters instead of fetching all posts
303: 6. **Paginate large results** - Use `limit` and `offset` for better performance with large datasets
</file>

<file path="scripts/start.sh">
  1: #!/bin/bash
  2: # MCP Agent Social Media Server Startup Script
  3: # This script provides a robust way to start the server with proper checks
  4: set -e  # Exit on any error
  5: # Configuration
  6: SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  7: PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
  8: LOG_FILE="${PROJECT_ROOT}/logs/startup.log"
  9: PID_FILE="${PROJECT_ROOT}/tmp/server.pid"
 10: # Colors for output
 11: RED='\033[0;31m'
 12: GREEN='\033[0;32m'
 13: YELLOW='\033[1;33m'
 14: BLUE='\033[0;34m'
 15: NC='\033[0m' # No Color
 16: # Logging functions
 17: log() {
 18:     echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
 19:     echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE" 2>/dev/null || true
 20: }
 21: error() {
 22:     echo -e "${RED}[ERROR]${NC} $1" >&2
 23:     echo "[ERROR] $1" >> "$LOG_FILE" 2>/dev/null || true
 24: }
 25: warn() {
 26:     echo -e "${YELLOW}[WARN]${NC} $1"
 27:     echo "[WARN] $1" >> "$LOG_FILE" 2>/dev/null || true
 28: }
 29: success() {
 30:     echo -e "${GREEN}[SUCCESS]${NC} $1"
 31:     echo "[SUCCESS] $1" >> "$LOG_FILE" 2>/dev/null || true
 32: }
 33: # Help function
 34: show_help() {
 35:     cat << EOF
 36: MCP Agent Social Media Server Startup Script
 37: Usage: $0 [OPTIONS]
 38: Options:
 39:     -h, --help          Show this help message
 40:     -d, --dev           Start in development mode
 41:     -p, --prod          Start in production mode
 42:     -c, --check         Check configuration and dependencies
 43:     -s, --stop          Stop running server
 44:     -r, --restart       Restart server
 45:     -t, --test          Run tests before starting
 46:     --no-build          Skip build step
 47:     --no-logs           Don't tail logs after starting
 48:     --background        Start in background mode
 49: Examples:
 50:     $0                  # Start server with current environment
 51:     $0 --dev            # Start in development mode
 52:     $0 --prod           # Start in production mode
 53:     $0 --check          # Check configuration only
 54:     $0 --restart        # Restart server
 55: Environment Variables:
 56:     TEAM_NAME           Team namespace (required)
 57:     SOCIAL_API_BASE_URL External API base URL (required)
 58:     SOCIAL_API_KEY      API authentication key (required)
 59:     LOG_LEVEL           Logging level (optional)
 60:     NODE_ENV            Node environment (optional)
 61: EOF
 62: }
 63: # Cleanup function
 64: cleanup() {
 65:     if [[ -f "$PID_FILE" ]]; then
 66:         local pid=$(cat "$PID_FILE")
 67:         if kill -0 "$pid" 2>/dev/null; then
 68:             log "Cleaning up process $pid"
 69:             kill "$pid" 2>/dev/null || true
 70:             sleep 2
 71:             kill -9 "$pid" 2>/dev/null || true
 72:         fi
 73:         rm -f "$PID_FILE"
 74:     fi
 75: }
 76: # Trap cleanup on script exit
 77: trap cleanup EXIT INT TERM
 78: # Check if server is running
 79: is_running() {
 80:     if [[ -f "$PID_FILE" ]]; then
 81:         local pid=$(cat "$PID_FILE")
 82:         kill -0 "$pid" 2>/dev/null
 83:     else
 84:         false
 85:     fi
 86: }
 87: # Stop server
 88: stop_server() {
 89:     if is_running; then
 90:         local pid=$(cat "$PID_FILE")
 91:         log "Stopping server (PID: $pid)"
 92:         kill "$pid"
 93:         # Wait for graceful shutdown
 94:         local count=0
 95:         while kill -0 "$pid" 2>/dev/null && [[ $count -lt 30 ]]; do
 96:             sleep 1
 97:             count=$((count + 1))
 98:         done
 99:         if kill -0 "$pid" 2>/dev/null; then
100:             warn "Forcing server shutdown"
101:             kill -9 "$pid"
102:         fi
103:         rm -f "$PID_FILE"
104:         success "Server stopped"
105:     else
106:         warn "Server is not running"
107:     fi
108: }
109: # Check prerequisites
110: check_prerequisites() {
111:     log "Checking prerequisites..."
112:     # Check Node.js version
113:     if ! command -v node &> /dev/null; then
114:         error "Node.js is not installed"
115:         return 1
116:     fi
117:     local node_version=$(node --version | cut -d'v' -f2)
118:     local min_version="18.0.0"
119:     if ! printf '%s\n%s\n' "$min_version" "$node_version" | sort -V -C; then
120:         error "Node.js version $node_version is too old. Minimum required: $min_version"
121:         return 1
122:     fi
123:     log "Node.js version: $node_version ✓"
124:     # Check npm
125:     if ! command -v npm &> /dev/null; then
126:         error "npm is not installed"
127:         return 1
128:     fi
129:     log "npm version: $(npm --version) ✓"
130:     # Check if we're in the right directory
131:     if [[ ! -f "$PROJECT_ROOT/package.json" ]]; then
132:         error "package.json not found. Are you in the correct directory?"
133:         return 1
134:     fi
135:     log "Project structure ✓"
136:     return 0
137: }
138: # Check configuration
139: check_configuration() {
140:     log "Checking configuration..."
141:     local missing_vars=()
142:     # Check required environment variables
143:     [[ -z "$TEAM_NAME" ]] && missing_vars+=("TEAM_NAME")
144:     [[ -z "$SOCIAL_API_BASE_URL" ]] && missing_vars+=("SOCIAL_API_BASE_URL")
145:     [[ -z "$SOCIAL_API_KEY" ]] && missing_vars+=("SOCIAL_API_KEY")
146:     if [[ ${#missing_vars[@]} -gt 0 ]]; then
147:         error "Missing required environment variables: ${missing_vars[*]}"
148:         error "Create a .env file or set these variables in your environment"
149:         return 1
150:     fi
151:     # Validate URL format
152:     if [[ ! "$SOCIAL_API_BASE_URL" =~ ^https?:// ]]; then
153:         error "SOCIAL_API_BASE_URL must start with http:// or https://"
154:         return 1
155:     fi
156:     log "Required configuration ✓"
157:     # Check optional variables
158:     log "Optional configuration:"
159:     log "  LOG_LEVEL: ${LOG_LEVEL:-INFO}"
160:     log "  NODE_ENV: ${NODE_ENV:-development}"
161:     log "  PORT: ${PORT:-3000}"
162:     return 0
163: }
164: # Install dependencies
165: install_dependencies() {
166:     log "Installing dependencies..."
167:     if [[ ! -d "$PROJECT_ROOT/node_modules" ]] || [[ "$PROJECT_ROOT/package.json" -nt "$PROJECT_ROOT/node_modules/.package-lock.json" ]]; then
168:         log "Running npm install..."
169:         cd "$PROJECT_ROOT"
170:         npm install || {
171:             error "Failed to install dependencies"
172:             return 1
173:         }
174:         success "Dependencies installed"
175:     else
176:         log "Dependencies up to date ✓"
177:     fi
178:     return 0
179: }
180: # Build project
181: build_project() {
182:     if [[ "$SKIP_BUILD" != "true" ]]; then
183:         log "Building project..."
184:         cd "$PROJECT_ROOT"
185:         if [[ ! -d "build" ]] || [[ "src" -nt "build" ]]; then
186:             npm run build || {
187:                 error "Build failed"
188:                 return 1
189:             }
190:             success "Build completed"
191:         else
192:             log "Build up to date ✓"
193:         fi
194:     else
195:         log "Skipping build (--no-build specified)"
196:     fi
197:     return 0
198: }
199: # Run tests
200: run_tests() {
201:     if [[ "$RUN_TESTS" == "true" ]]; then
202:         log "Running tests..."
203:         cd "$PROJECT_ROOT"
204:         npm test || {
205:             error "Tests failed"
206:             return 1
207:         }
208:         success "All tests passed"
209:     fi
210:     return 0
211: }
212: # Start server
213: start_server() {
214:     if is_running; then
215:         warn "Server is already running (PID: $(cat "$PID_FILE"))"
216:         return 0
217:     fi
218:     log "Starting MCP Agent Social Media Server..."
219:     # Create necessary directories
220:     mkdir -p "$(dirname "$LOG_FILE")" "$(dirname "$PID_FILE")"
221:     cd "$PROJECT_ROOT"
222:     if [[ "$BACKGROUND" == "true" ]]; then
223:         # Start in background
224:         nohup node build/index.js > "$LOG_FILE" 2>&1 &
225:         echo $! > "$PID_FILE"
226:         # Wait a moment and check if it started successfully
227:         sleep 2
228:         if is_running; then
229:             success "Server started in background (PID: $(cat "$PID_FILE"))"
230:             log "Log file: $LOG_FILE"
231:         else
232:             error "Failed to start server"
233:             return 1
234:         fi
235:     else
236:         # Start in foreground
237:         log "Server starting in foreground mode..."
238:         log "Press Ctrl+C to stop"
239:         # Start and capture PID
240:         node build/index.js &
241:         echo $! > "$PID_FILE"
242:         if [[ "$NO_LOGS" != "true" ]]; then
243:             # Wait for server to start then tail logs
244:             sleep 2
245:             if is_running; then
246:                 success "Server started (PID: $(cat "$PID_FILE"))"
247:                 log "Tailing logs (Ctrl+C to stop)..."
248:                 tail -f "$LOG_FILE" 2>/dev/null || wait
249:             else
250:                 error "Failed to start server"
251:                 return 1
252:             fi
253:         else
254:             wait
255:         fi
256:     fi
257:     return 0
258: }
259: # Parse command line arguments
260: DEVELOPMENT_MODE=false
261: PRODUCTION_MODE=false
262: CHECK_ONLY=false
263: STOP_SERVER=false
264: RESTART_SERVER=false
265: RUN_TESTS=false
266: SKIP_BUILD=false
267: NO_LOGS=false
268: BACKGROUND=false
269: while [[ $# -gt 0 ]]; do
270:     case $1 in
271:         -h|--help)
272:             show_help
273:             exit 0
274:             ;;
275:         -d|--dev)
276:             DEVELOPMENT_MODE=true
277:             export NODE_ENV=development
278:             export LOG_LEVEL=DEBUG
279:             shift
280:             ;;
281:         -p|--prod)
282:             PRODUCTION_MODE=true
283:             export NODE_ENV=production
284:             export LOG_LEVEL=WARN
285:             shift
286:             ;;
287:         -c|--check)
288:             CHECK_ONLY=true
289:             shift
290:             ;;
291:         -s|--stop)
292:             STOP_SERVER=true
293:             shift
294:             ;;
295:         -r|--restart)
296:             RESTART_SERVER=true
297:             shift
298:             ;;
299:         -t|--test)
300:             RUN_TESTS=true
301:             shift
302:             ;;
303:         --no-build)
304:             SKIP_BUILD=true
305:             shift
306:             ;;
307:         --no-logs)
308:             NO_LOGS=true
309:             shift
310:             ;;
311:         --background)
312:             BACKGROUND=true
313:             shift
314:             ;;
315:         *)
316:             error "Unknown option: $1"
317:             show_help
318:             exit 1
319:             ;;
320:     esac
321: done
322: # Load .env file if it exists
323: if [[ -f "$PROJECT_ROOT/.env" ]]; then
324:     log "Loading environment from .env"
325:     set -a
326:     source "$PROJECT_ROOT/.env"
327:     set +a
328: fi
329: # Main execution
330: main() {
331:     log "MCP Agent Social Media Server Startup Script"
332:     log "Project root: $PROJECT_ROOT"
333:     # Handle stop/restart commands
334:     if [[ "$STOP_SERVER" == "true" ]]; then
335:         stop_server
336:         exit $?
337:     fi
338:     if [[ "$RESTART_SERVER" == "true" ]]; then
339:         stop_server
340:         sleep 2
341:     fi
342:     # Check prerequisites
343:     if ! check_prerequisites; then
344:         exit 1
345:     fi
346:     # Check configuration
347:     if ! check_configuration; then
348:         exit 1
349:     fi
350:     if [[ "$CHECK_ONLY" == "true" ]]; then
351:         success "Configuration check passed"
352:         exit 0
353:     fi
354:     # Install dependencies
355:     if ! install_dependencies; then
356:         exit 1
357:     fi
358:     # Build project
359:     if ! build_project; then
360:         exit 1
361:     fi
362:     # Run tests if requested
363:     if ! run_tests; then
364:         exit 1
365:     fi
366:     # Start server
367:     if ! start_server; then
368:         exit 1
369:     fi
370: }
371: # Run main function
372: main "$@"
</file>

<file path="src/logger.ts">
  1: // ABOUTME: Enhanced logging utility for the MCP Agent Social Media Server
  2: // ABOUTME: Provides structured logging with levels, context, and performance tracking
  3: export enum LogLevel {
  4:   ERROR = 0,
  5:   WARN = 1,
  6:   INFO = 2,
  7:   DEBUG = 3,
  8: }
  9: export interface LogContext {
 10:   tool?: string;
 11:   sessionId?: string;
 12:   agentName?: string;
 13:   requestId?: string;
 14:   [key: string]: unknown;
 15: }
 16: export class Logger {
 17:   private static instance: Logger;
 18:   private logLevel: LogLevel;
 19:   private startTime: number;
 20:   private constructor() {
 21:     this.logLevel = this.parseLogLevel(process.env.LOG_LEVEL || 'INFO');
 22:     this.startTime = Date.now();
 23:   }
 24:   static getInstance(): Logger {
 25:     if (!Logger.instance) {
 26:       Logger.instance = new Logger();
 27:     }
 28:     return Logger.instance;
 29:   }
 30:   private parseLogLevel(level: string): LogLevel {
 31:     switch (level.toUpperCase()) {
 32:       case 'ERROR':
 33:         return LogLevel.ERROR;
 34:       case 'WARN':
 35:         return LogLevel.WARN;
 36:       case 'INFO':
 37:         return LogLevel.INFO;
 38:       case 'DEBUG':
 39:         return LogLevel.DEBUG;
 40:       default:
 41:         return LogLevel.INFO;
 42:     }
 43:   }
 44:   private formatMessage(level: string, message: string, context?: LogContext): string {
 45:     const timestamp = new Date().toISOString();
 46:     const uptime = Math.floor((Date.now() - this.startTime) / 1000);
 47:     const contextStr = context ? ` ${JSON.stringify(context)}` : '';
 48:     return `[${timestamp}] [${level}] [uptime:${uptime}s] ${message}${contextStr}`;
 49:   }
 50:   private log(level: LogLevel, levelStr: string, message: string, context?: LogContext): void {
 51:     if (level <= this.logLevel) {
 52:       const formattedMessage = this.formatMessage(levelStr, message, context);
 53:       if (level === LogLevel.ERROR) {
 54:         console.error(formattedMessage);
 55:       } else {
 56:         console.log(formattedMessage);
 57:       }
 58:     }
 59:   }
 60:   error(message: string, context?: LogContext): void {
 61:     this.log(LogLevel.ERROR, 'ERROR', message, context);
 62:   }
 63:   warn(message: string, context?: LogContext): void {
 64:     this.log(LogLevel.WARN, 'WARN', message, context);
 65:   }
 66:   info(message: string, context?: LogContext): void {
 67:     this.log(LogLevel.INFO, 'INFO', message, context);
 68:   }
 69:   debug(message: string, context?: LogContext): void {
 70:     this.log(LogLevel.DEBUG, 'DEBUG', message, context);
 71:   }
 72:   // Tool-specific logging helpers
 73:   toolStart(toolName: string, args: unknown, context?: LogContext): void {
 74:     this.info(`Tool ${toolName} started`, {
 75:       tool: toolName,
 76:       args: args,
 77:       ...context,
 78:     });
 79:   }
 80:   toolSuccess(toolName: string, duration: number, context?: LogContext): void {
 81:     this.info(`Tool ${toolName} completed`, {
 82:       tool: toolName,
 83:       duration: `${duration}ms`,
 84:       status: 'success',
 85:       ...context,
 86:     });
 87:   }
 88:   toolError(toolName: string, error: Error, duration: number, context?: LogContext): void {
 89:     this.error(`Tool ${toolName} failed`, {
 90:       tool: toolName,
 91:       duration: `${duration}ms`,
 92:       status: 'error',
 93:       error: error.message,
 94:       stack: error.stack,
 95:       ...context,
 96:     });
 97:   }
 98:   // Session-specific logging
 99:   sessionCreated(sessionId: string, agentName: string): void {
100:     this.info('Session created', { sessionId, agentName, event: 'session_created' });
101:   }
102:   sessionDeleted(sessionId: string, agentName?: string): void {
103:     this.info('Session deleted', { sessionId, agentName, event: 'session_deleted' });
104:   }
105:   sessionValidationFailed(sessionId: string, reason: string): void {
106:     this.warn('Session validation failed', {
107:       sessionId,
108:       reason,
109:       event: 'session_validation_failed',
110:     });
111:   }
112:   // API-specific logging
113:   apiRequest(method: string, url: string, context?: LogContext): void {
114:     this.debug(`API request: ${method} ${url}`, {
115:       method,
116:       url,
117:       event: 'api_request',
118:       ...context,
119:     });
120:   }
121:   apiResponse(
122:     method: string,
123:     url: string,
124:     status: number,
125:     duration: number,
126:     context?: LogContext
127:   ): void {
128:     const logMethod = status >= 400 ? this.warn.bind(this) : this.debug.bind(this);
129:     logMethod(`API response: ${method} ${url} - ${status}`, {
130:       method,
131:       url,
132:       status,
133:       duration: `${duration}ms`,
134:       event: 'api_response',
135:       ...context,
136:     });
137:   }
138:   apiError(method: string, url: string, error: Error, context?: LogContext): void {
139:     this.error(`API error: ${method} ${url}`, {
140:       method,
141:       url,
142:       error: error.message,
143:       event: 'api_error',
144:       ...context,
145:     });
146:   }
147:   // Performance logging
148:   performance(operation: string, duration: number, context?: LogContext): void {
149:     const logMethod = duration > 1000 ? this.warn.bind(this) : this.info.bind(this);
150:     logMethod(`Performance: ${operation}`, {
151:       operation,
152:       duration: `${duration}ms`,
153:       slow: duration > 1000,
154:       ...context,
155:     });
156:   }
157: }
158: // Export singleton instance
159: export const logger = Logger.getInstance();
</file>

<file path="src/metrics.ts">
  1: // ABOUTME: Basic performance monitoring and metrics collection
  2: // ABOUTME: Tracks operation timings, memory usage, and system health
  3: export interface Metric {
  4:   name: string;
  5:   value: number;
  6:   timestamp: Date;
  7:   tags?: Record<string, string>;
  8: }
  9: export interface OperationMetrics {
 10:   count: number;
 11:   totalDuration: number;
 12:   minDuration: number;
 13:   maxDuration: number;
 14:   averageDuration: number;
 15:   lastDuration: number;
 16:   errors: number;
 17: }
 18: export class MetricsCollector {
 19:   private static instance: MetricsCollector;
 20:   private metrics: Map<string, OperationMetrics>;
 21:   private startTime: number;
 22:   private sessionCount: number;
 23:   private activeOperations: Map<string, number>;
 24:   private constructor() {
 25:     this.metrics = new Map();
 26:     this.startTime = Date.now();
 27:     this.sessionCount = 0;
 28:     this.activeOperations = new Map();
 29:   }
 30:   static getInstance(): MetricsCollector {
 31:     if (!MetricsCollector.instance) {
 32:       MetricsCollector.instance = new MetricsCollector();
 33:     }
 34:     return MetricsCollector.instance;
 35:   }
 36:   // Start tracking an operation
 37:   startOperation(operationName: string): string {
 38:     const operationId = `${operationName}_${Date.now()}_${Math.random()}`;
 39:     this.activeOperations.set(operationId, Date.now());
 40:     return operationId;
 41:   }
 42:   // End tracking an operation
 43:   endOperation(operationId: string, success: boolean = true): void {
 44:     const startTime = this.activeOperations.get(operationId);
 45:     if (!startTime) {
 46:       return;
 47:     }
 48:     const duration = Date.now() - startTime;
 49:     this.activeOperations.delete(operationId);
 50:     // Extract operation name from ID
 51:     const operationName = operationId.split('_')[0];
 52:     this.recordOperation(operationName, duration, success);
 53:   }
 54:   // Record an operation metric
 55:   private recordOperation(name: string, duration: number, success: boolean): void {
 56:     let metrics = this.metrics.get(name);
 57:     if (!metrics) {
 58:       metrics = {
 59:         count: 0,
 60:         totalDuration: 0,
 61:         minDuration: Infinity,
 62:         maxDuration: 0,
 63:         averageDuration: 0,
 64:         lastDuration: 0,
 65:         errors: 0,
 66:       };
 67:       this.metrics.set(name, metrics);
 68:     }
 69:     metrics.count++;
 70:     metrics.totalDuration += duration;
 71:     metrics.minDuration = Math.min(metrics.minDuration, duration);
 72:     metrics.maxDuration = Math.max(metrics.maxDuration, duration);
 73:     metrics.averageDuration = metrics.totalDuration / metrics.count;
 74:     metrics.lastDuration = duration;
 75:     if (!success) {
 76:       metrics.errors++;
 77:     }
 78:   }
 79:   // Session management metrics
 80:   incrementSessionCount(): void {
 81:     this.sessionCount++;
 82:   }
 83:   decrementSessionCount(): void {
 84:     this.sessionCount = Math.max(0, this.sessionCount - 1);
 85:   }
 86:   getSessionCount(): number {
 87:     return this.sessionCount;
 88:   }
 89:   // Get metrics for a specific operation
 90:   getOperationMetrics(operationName: string): OperationMetrics | undefined {
 91:     return this.metrics.get(operationName);
 92:   }
 93:   // Get all metrics
 94:   getAllMetrics(): Record<string, OperationMetrics> {
 95:     const result: Record<string, OperationMetrics> = {};
 96:     this.metrics.forEach((value, key) => {
 97:       result[key] = { ...value };
 98:     });
 99:     return result;
100:   }
101:   // Get system metrics
102:   getSystemMetrics(): {
103:     uptime: number;
104:     memoryUsage: ReturnType<typeof process.memoryUsage>;
105:     sessionCount: number;
106:     activeOperations: number;
107:   } {
108:     return {
109:       uptime: Math.floor((Date.now() - this.startTime) / 1000),
110:       memoryUsage: process.memoryUsage(),
111:       sessionCount: this.sessionCount,
112:       activeOperations: this.activeOperations.size,
113:     };
114:   }
115:   // Get formatted summary
116:   getSummary(): string {
117:     const system = this.getSystemMetrics();
118:     const operations = this.getAllMetrics();
119:     let summary = `=== System Metrics ===\n`;
120:     summary += `Uptime: ${system.uptime}s\n`;
121:     summary += `Memory (RSS): ${Math.round(system.memoryUsage.rss / 1024 / 1024)}MB\n`;
122:     summary += `Memory (Heap Used): ${Math.round(system.memoryUsage.heapUsed / 1024 / 1024)}MB\n`;
123:     summary += `Active Sessions: ${system.sessionCount}\n`;
124:     summary += `Active Operations: ${system.activeOperations}\n\n`;
125:     summary += `=== Operation Metrics ===\n`;
126:     Object.entries(operations).forEach(([name, metrics]) => {
127:       summary += `${name}:\n`;
128:       summary += `  Count: ${metrics.count}\n`;
129:       summary += `  Avg Duration: ${Math.round(metrics.averageDuration)}ms\n`;
130:       summary += `  Min Duration: ${Math.round(metrics.minDuration)}ms\n`;
131:       summary += `  Max Duration: ${Math.round(metrics.maxDuration)}ms\n`;
132:       summary += `  Error Rate: ${((metrics.errors / metrics.count) * 100).toFixed(2)}%\n`;
133:     });
134:     return summary;
135:   }
136:   // Reset all metrics (useful for testing)
137:   reset(): void {
138:     this.metrics.clear();
139:     this.activeOperations.clear();
140:     this.sessionCount = 0;
141:   }
142: }
143: // Export singleton instance
144: export const metrics = MetricsCollector.getInstance();
145: // Helper function for timing async operations
146: export async function withMetrics<T>(
147:   operationName: string,
148:   operation: () => Promise<T>
149: ): Promise<T> {
150:   const operationId = metrics.startOperation(operationName);
151:   try {
152:     const result = await operation();
153:     metrics.endOperation(operationId, true);
154:     return result;
155:   } catch (error) {
156:     metrics.endOperation(operationId, false);
157:     throw error;
158:   }
159: }
</file>

<file path="src/validation.ts">
  1: // ABOUTME: JSON Schema validation utilities for MCP tools
  2: // ABOUTME: Provides runtime validation for tool inputs
  3: export interface ValidationError {
  4:   field: string;
  5:   message: string;
  6: }
  7: export class ValidationResult {
  8:   constructor(
  9:     public isValid: boolean,
 10:     public errors: ValidationError[] = [],
 11:     public data?: any
 12:   ) {}
 13:   static success(data: any): ValidationResult {
 14:     return new ValidationResult(true, [], data);
 15:   }
 16:   static failure(errors: ValidationError[]): ValidationResult {
 17:     return new ValidationResult(false, errors);
 18:   }
 19: }
 20: export function validateString(
 21:   value: any,
 22:   field: string,
 23:   options: { minLength?: number; maxLength?: number; required?: boolean } = {}
 24: ): ValidationError[] {
 25:   const errors: ValidationError[] = [];
 26:   if (options.required && (value === undefined || value === null)) {
 27:     if (field === 'content') {
 28:       errors.push({ field, message: 'Content must not be empty' });
 29:     } else {
 30:       errors.push({ field, message: `${field} is required` });
 31:     }
 32:     return errors;
 33:   }
 34:   if (value !== undefined && value !== null) {
 35:     if (typeof value !== 'string') {
 36:       errors.push({ field, message: `${field} must be a string` });
 37:       return errors;
 38:     }
 39:     // For content validation, check if trimmed string is empty
 40:     if (field === 'content' && options.required && value.trim().length === 0) {
 41:       errors.push({ field, message: 'Content must not be empty' });
 42:       return errors;
 43:     }
 44:     if (options.minLength && value.length < options.minLength) {
 45:       if (field === 'content') {
 46:         errors.push({ field, message: 'Content must not be empty' });
 47:       } else {
 48:         errors.push({
 49:           field,
 50:           message: `${field} must be at least ${options.minLength} characters`,
 51:         });
 52:       }
 53:     }
 54:     if (options.maxLength && value.length > options.maxLength) {
 55:       errors.push({ field, message: `${field} must be at most ${options.maxLength} characters` });
 56:     }
 57:   }
 58:   return errors;
 59: }
 60: export function validateNumber(
 61:   value: any,
 62:   field: string,
 63:   options: { min?: number; max?: number; required?: boolean } = {}
 64: ): ValidationError[] {
 65:   const errors: ValidationError[] = [];
 66:   if (options.required && (value === undefined || value === null)) {
 67:     errors.push({ field, message: `${field} is required` });
 68:     return errors;
 69:   }
 70:   if (value !== undefined && value !== null) {
 71:     if (typeof value !== 'number' || isNaN(value)) {
 72:       errors.push({ field, message: `${field} must be a number` });
 73:       return errors;
 74:     }
 75:     if (options.min !== undefined && value < options.min) {
 76:       errors.push({ field, message: `${field} must be at least ${options.min}` });
 77:     }
 78:     if (options.max !== undefined && value > options.max) {
 79:       errors.push({ field, message: `${field} must be at most ${options.max}` });
 80:     }
 81:   }
 82:   return errors;
 83: }
 84: export function validateArray(
 85:   value: any,
 86:   field: string,
 87:   options: {
 88:     required?: boolean;
 89:     itemValidator?: (item: any, index: number) => ValidationError[];
 90:   } = {}
 91: ): ValidationError[] {
 92:   const errors: ValidationError[] = [];
 93:   if (options.required && (value === undefined || value === null)) {
 94:     errors.push({ field, message: `${field} is required` });
 95:     return errors;
 96:   }
 97:   if (value !== undefined && value !== null) {
 98:     if (!Array.isArray(value)) {
 99:       errors.push({ field, message: `${field} must be an array` });
100:       return errors;
101:     }
102:     if (options.itemValidator) {
103:       value.forEach((item, index) => {
104:         const itemErrors = options.itemValidator!(item, index);
105:         errors.push(
106:           ...itemErrors.map((err) => ({
107:             field: `${field}[${index}].${err.field}`,
108:             message: err.message,
109:           }))
110:         );
111:       });
112:     }
113:   }
114:   return errors;
115: }
116: // Login tool validation
117: export function validateLoginInput(input: any): ValidationResult {
118:   const errors: ValidationError[] = [];
119:   // Special handling for agent_name
120:   if (input.agent_name === undefined || input.agent_name === null) {
121:     errors.push({ field: 'agent_name', message: 'Agent name must not be empty' });
122:   } else if (typeof input.agent_name !== 'string') {
123:     errors.push({ field: 'agent_name', message: 'Agent name must be a string' });
124:   } else if (input.agent_name.trim().length === 0) {
125:     errors.push({ field: 'agent_name', message: 'Agent name must not be empty' });
126:   }
127:   if (errors.length > 0) {
128:     return ValidationResult.failure(errors);
129:   }
130:   return ValidationResult.success({
131:     agent_name: input.agent_name.trim(),
132:   });
133: }
134: // Read posts tool validation
135: export function validateReadPostsInput(input: any): ValidationResult {
136:   const errors: ValidationError[] = [];
137:   // Apply defaults
138:   const data = {
139:     limit: input.limit ?? 10,
140:     offset: input.offset ?? 0,
141:     agent_filter: input.agent_filter,
142:     tag_filter: input.tag_filter,
143:     thread_id: input.thread_id,
144:   };
145:   errors.push(...validateNumber(data.limit, 'limit', { min: 1, max: 100 }));
146:   errors.push(...validateNumber(data.offset, 'offset', { min: 0 }));
147:   // Check for empty string filters
148:   if (typeof data.agent_filter === 'string' && data.agent_filter.trim() === '') {
149:     errors.push({ field: 'agent_filter', message: 'agent_filter cannot be empty' });
150:   }
151:   if (typeof data.tag_filter === 'string' && data.tag_filter.trim() === '') {
152:     errors.push({ field: 'tag_filter', message: 'tag_filter cannot be empty' });
153:   }
154:   if (typeof data.thread_id === 'string' && data.thread_id.trim() === '') {
155:     errors.push({ field: 'thread_id', message: 'thread_id cannot be empty' });
156:   }
157:   if (errors.length > 0) {
158:     return ValidationResult.failure(errors);
159:   }
160:   return ValidationResult.success(data);
161: }
162: // Create post tool validation
163: export function validateCreatePostInput(input: any): ValidationResult {
164:   const errors: ValidationError[] = [];
165:   errors.push(
166:     ...validateString(input.content, 'content', {
167:       required: true,
168:       minLength: 1,
169:     })
170:   );
171:   errors.push(...validateString(input.parent_post_id, 'parent_post_id'));
172:   if (input.tags !== undefined) {
173:     errors.push(
174:       ...validateArray(input.tags, 'tags', {
175:         itemValidator: (item, _index) => validateString(item, 'item', {}),
176:       })
177:     );
178:   }
179:   if (errors.length > 0) {
180:     return ValidationResult.failure(errors);
181:   }
182:   // Filter and trim tags
183:   const filteredTags =
184:     input.tags?.filter((tag: string) => tag && tag.trim()).map((tag: string) => tag.trim()) || [];
185:   return ValidationResult.success({
186:     content: input.content.trim(),
187:     tags: filteredTags,
188:     parent_post_id: input.parent_post_id,
189:   });
190: }
</file>

<file path="tests/integration/end-to-end.test.ts">
  1: // ABOUTME: End-to-end integration tests for complete workflows
  2: // ABOUTME: Tests full agent interactions including login, posting, and replies
  3: import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
  4: import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
  5: import { SessionManager } from '../../src/session-manager.js';
  6: import { MockApiClient } from '../../src/mock-api-client.js';
  7: import { loginToolHandler } from '../../src/tools/login.js';
  8: import { readPostsToolHandler } from '../../src/tools/read-posts.js';
  9: import { createPostToolHandler } from '../../src/tools/create-post.js';
 10: import { logger } from '../../src/logger.js';
 11: import { metrics } from '../../src/metrics.js';
 12: describe('End-to-End Integration Tests', () => {
 13:   let sessionManager: SessionManager;
 14:   let apiClient: MockApiClient;
 15:   let sessionId: string;
 16:   beforeEach(() => {
 17:     // Reset environment
 18:     process.env.TEAM_NAME = 'test-team';
 19:     process.env.LOG_LEVEL = 'DEBUG';
 20:     // Initialize components
 21:     sessionManager = new SessionManager();
 22:     apiClient = new MockApiClient();
 23:     sessionId = `test-session-${Date.now()}`;
 24:     // Reset metrics
 25:     metrics.reset();
 26:   });
 27:   afterEach(() => {
 28:     // Clean up
 29:     sessionManager.clearAllSessions();
 30:   });
 31:   describe('Complete Agent Workflow', () => {
 32:     it('should handle complete workflow: login → read → create → read updated', async () => {
 33:       logger.info('Starting complete agent workflow test');
 34:       // Step 1: Login
 35:       const loginContext = {
 36:         sessionManager,
 37:         getSessionId: () => sessionId,
 38:       };
 39:       const loginResult = await loginToolHandler({ agent_name: 'test-agent' }, loginContext);
 40:       const loginResponse = JSON.parse(loginResult.content[0].text);
 41:       expect(loginResponse.success).toBe(true);
 42:       expect(loginResponse.agent_name).toBe('test-agent');
 43:       logger.info('Login successful', { agent_name: 'test-agent' });
 44:       // Step 2: Read initial posts
 45:       const readContext = {
 46:         apiClient,
 47:       };
 48:       const initialReadResult = await readPostsToolHandler({}, readContext);
 49:       const initialPosts = JSON.parse(initialReadResult.content[0].text);
 50:       expect(initialPosts.posts).toBeDefined();
 51:       const initialPostCount = initialPosts.posts.length;
 52:       logger.info('Initial post count', { count: initialPostCount });
 53:       // Step 3: Create a new post
 54:       const createContext = {
 55:         sessionManager,
 56:         apiClient,
 57:         getSessionId: () => sessionId,
 58:       };
 59:       const createResult = await createPostToolHandler(
 60:         {
 61:           content: 'Integration test post',
 62:           tags: ['test', 'integration'],
 63:         },
 64:         createContext
 65:       );
 66:       const createResponse = JSON.parse(createResult.content[0].text);
 67:       expect(createResponse.success).toBe(true);
 68:       expect(createResponse.post).toBeDefined();
 69:       const newPostId = createResponse.post.id;
 70:       logger.info('Post created', { postId: newPostId });
 71:       // Step 4: Read updated feed
 72:       const updatedReadResult = await readPostsToolHandler({}, readContext);
 73:       const updatedPosts = JSON.parse(updatedReadResult.content[0].text);
 74:       expect(updatedPosts.posts.length).toBe(initialPostCount + 1);
 75:       // Verify our post is in the feed
 76:       const ourPost = updatedPosts.posts.find((p: any) => p.id === newPostId);
 77:       expect(ourPost).toBeDefined();
 78:       expect(ourPost.content).toBe('Integration test post');
 79:       expect(ourPost.author_name).toBe('test-agent');
 80:       logger.info('Post verified in feed');
 81:     });
 82:   });
 83:   describe('Reply Workflow', () => {
 84:     it('should handle reply workflow: login → read → create reply → verify threading', async () => {
 85:       logger.info('Starting reply workflow test');
 86:       // Setup: Add a parent post
 87:       const parentPost = {
 88:         id: 'parent-post-integration',
 89:         team_name: 'test-team',
 90:         author_name: 'other-agent',
 91:         content: 'Parent post for replies',
 92:         tags: ['discussion'],
 93:         timestamp: new Date().toISOString(),
 94:       };
 95:       apiClient.addPost(parentPost);
 96:       // Step 1: Login
 97:       const loginContext = {
 98:         sessionManager,
 99:         getSessionId: () => sessionId,
100:       };
101:       await loginToolHandler({ agent_name: 'reply-agent' }, loginContext);
102:       // Step 2: Read posts to find parent
103:       const readContext = {
104:         apiClient,
105:       };
106:       const readResult = await readPostsToolHandler({}, readContext);
107:       const posts = JSON.parse(readResult.content[0].text);
108:       const foundParent = posts.posts.find((p: any) => p.id === parentPost.id);
109:       expect(foundParent).toBeDefined();
110:       // Step 3: Create reply
111:       const createContext = {
112:         sessionManager,
113:         apiClient,
114:         getSessionId: () => sessionId,
115:       };
116:       const replyResult = await createPostToolHandler(
117:         {
118:           content: 'This is a reply to the parent post',
119:           parent_post_id: parentPost.id,
120:         },
121:         createContext
122:       );
123:       const replyResponse = JSON.parse(replyResult.content[0].text);
124:       expect(replyResponse.success).toBe(true);
125:       expect(replyResponse.post.parent_post_id).toBe(parentPost.id);
126:       const replyId = replyResponse.post.id;
127:       // Step 4: Verify threading with thread_id filter
128:       const threadResult = await readPostsToolHandler({ thread_id: parentPost.id }, readContext);
129:       const threadPosts = JSON.parse(threadResult.content[0].text);
130:       expect(threadPosts.posts.length).toBeGreaterThanOrEqual(2);
131:       // Should include both parent and reply
132:       const hasParent = threadPosts.posts.some((p: any) => p.id === parentPost.id);
133:       const hasReply = threadPosts.posts.some((p: any) => p.id === replyId);
134:       expect(hasParent).toBe(true);
135:       expect(hasReply).toBe(true);
136:       logger.info('Reply thread verified', {
137:         parentId: parentPost.id,
138:         replyId,
139:         threadSize: threadPosts.posts.length,
140:       });
141:     });
142:   });
143:   describe('Error Scenarios', () => {
144:     it('should handle API failures gracefully', async () => {
145:       logger.info('Testing API failure handling');
146:       // Login first
147:       const loginContext = {
148:         sessionManager,
149:         getSessionId: () => sessionId,
150:       };
151:       await loginToolHandler({ agent_name: 'error-test-agent' }, loginContext);
152:       // Simulate API failure
153:       apiClient.setNetworkFailure(true);
154:       // Try to create post
155:       const createContext = {
156:         sessionManager,
157:         apiClient,
158:         getSessionId: () => sessionId,
159:       };
160:       const result = await createPostToolHandler({ content: 'This should fail' }, createContext);
161:       const response = JSON.parse(result.content[0].text);
162:       expect(response.success).toBe(false);
163:       expect(response.error).toBe('Failed to create post');
164:       logger.warn('API failure handled correctly');
165:       // Reset API
166:       apiClient.setNetworkFailure(false);
167:     });
168:     it('should enforce session requirements', async () => {
169:       logger.info('Testing session validation');
170:       // Try to create post without login
171:       const createContext = {
172:         sessionManager,
173:         apiClient,
174:         getSessionId: () => 'no-session',
175:       };
176:       const result = await createPostToolHandler({ content: 'Unauthorized post' }, createContext);
177:       const response = JSON.parse(result.content[0].text);
178:       expect(response.success).toBe(false);
179:       expect(response.error).toBe('Authentication required');
180:       logger.info('Session validation working correctly');
181:     });
182:   });
183:   describe('Multi-Agent Scenarios', () => {
184:     it('should handle multiple agents posting and reading', async () => {
185:       logger.info('Testing multi-agent scenario');
186:       const agents = ['alice', 'bob', 'charlie'];
187:       const sessions: Record<string, string> = {};
188:       // All agents login
189:       for (const agent of agents) {
190:         const agentSessionId = `session-${agent}`;
191:         sessions[agent] = agentSessionId;
192:         const loginContext = {
193:           sessionManager,
194:           getSessionId: () => agentSessionId,
195:         };
196:         await loginToolHandler({ agent_name: agent }, loginContext);
197:         logger.debug(`Agent ${agent} logged in`);
198:       }
199:       // Each agent creates a post
200:       const postIds: string[] = [];
201:       for (const agent of agents) {
202:         const createContext = {
203:           sessionManager,
204:           apiClient,
205:           getSessionId: () => sessions[agent],
206:         };
207:         const result = await createPostToolHandler(
208:           {
209:             content: `Post from ${agent}`,
210:             tags: [agent, 'multi-agent-test'],
211:           },
212:           createContext
213:         );
214:         const response = JSON.parse(result.content[0].text);
215:         expect(response.success).toBe(true);
216:         postIds.push(response.post.id);
217:         logger.debug(`Agent ${agent} created post ${response.post.id}`);
218:       }
219:       // Read all posts with agent filter
220:       const readContext = {
221:         apiClient,
222:       };
223:       for (const agent of agents) {
224:         const result = await readPostsToolHandler({ agent_filter: agent }, readContext);
225:         const response = JSON.parse(result.content[0].text);
226:         const agentPosts = response.posts.filter((p: any) => p.author_name === agent);
227:         expect(agentPosts.length).toBeGreaterThanOrEqual(1);
228:         logger.debug(`Found ${agentPosts.length} posts by ${agent}`);
229:       }
230:       // Create a conversation thread
231:       const alicePost = postIds[0];
232:       // Bob replies to Alice
233:       const bobReplyContext = {
234:         sessionManager,
235:         apiClient,
236:         getSessionId: () => sessions.bob,
237:       };
238:       const bobReply = await createPostToolHandler(
239:         {
240:           content: 'Reply from Bob to Alice',
241:           parent_post_id: alicePost,
242:         },
243:         bobReplyContext
244:       );
245:       const bobReplyResponse = JSON.parse(bobReply.content[0].text);
246:       expect(bobReplyResponse.success).toBe(true);
247:       // Charlie replies to Bob's reply
248:       const charlieReplyContext = {
249:         sessionManager,
250:         apiClient,
251:         getSessionId: () => sessions.charlie,
252:       };
253:       const charlieReply = await createPostToolHandler(
254:         {
255:           content: 'Reply from Charlie to Bob',
256:           parent_post_id: bobReplyResponse.post.id,
257:         },
258:         charlieReplyContext
259:       );
260:       const charlieReplyResponse = JSON.parse(charlieReply.content[0].text);
261:       expect(charlieReplyResponse.success).toBe(true);
262:       logger.info('Multi-agent conversation created successfully');
263:     });
264:   });
265:   describe('Performance Monitoring', () => {
266:     it('should track operation metrics', async () => {
267:       logger.info('Testing performance monitoring');
268:       // Reset metrics to ensure clean state
269:       metrics.reset();
270:       // Perform several operations
271:       const loginContext = {
272:         sessionManager,
273:         getSessionId: () => sessionId,
274:       };
275:       // Login - the handler already tracks metrics internally
276:       await loginToolHandler({ agent_name: 'metrics-agent' }, loginContext);
277:       // Create posts
278:       const createContext = {
279:         sessionManager,
280:         apiClient,
281:         getSessionId: () => sessionId,
282:       };
283:       for (let i = 0; i < 5; i++) {
284:         await createPostToolHandler({ content: `Performance test post ${i}` }, createContext);
285:       }
286:       // Read posts
287:       const readContext = {
288:         apiClient,
289:       };
290:       await readPostsToolHandler({ limit: 20 }, readContext);
291:       // Check metrics
292:       const loginMetrics = metrics.getOperationMetrics('login');
293:       expect(loginMetrics).toBeDefined();
294:       expect(loginMetrics!.count).toBe(1);
295:       expect(loginMetrics!.errors).toBe(0);
296:       const systemMetrics = metrics.getSystemMetrics();
297:       expect(systemMetrics.uptime).toBeGreaterThanOrEqual(0);
298:       expect(systemMetrics.memoryUsage).toBeDefined();
299:       expect(systemMetrics.memoryUsage.rss).toBeGreaterThan(0);
300:       logger.info('Metrics summary:\n' + metrics.getSummary());
301:     });
302:   });
303: });
</file>

<file path="tests/integration/session-lifecycle.test.ts">
  1: // ABOUTME: Integration tests for session lifecycle management
  2: // ABOUTME: Tests session creation, validation, cleanup, and edge cases
  3: import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
  4: import { SessionManager } from '../../src/session-manager.js';
  5: import { MockApiClient } from '../../src/mock-api-client.js';
  6: import { loginToolHandler } from '../../src/tools/login.js';
  7: import { createPostToolHandler } from '../../src/tools/create-post.js';
  8: import { logger } from '../../src/logger.js';
  9: import { metrics } from '../../src/metrics.js';
 10: describe('Session Lifecycle Integration Tests', () => {
 11:   let sessionManager: SessionManager;
 12:   let apiClient: MockApiClient;
 13:   beforeEach(() => {
 14:     process.env.TEAM_NAME = 'test-team';
 15:     sessionManager = new SessionManager();
 16:     apiClient = new MockApiClient();
 17:     metrics.reset();
 18:   });
 19:   afterEach(() => {
 20:     sessionManager.clearAllSessions();
 21:   });
 22:   describe('Session Creation and Validation', () => {
 23:     it('should handle session lifecycle correctly', async () => {
 24:       const sessionId = 'lifecycle-test-session';
 25:       const loginContext = {
 26:         sessionManager,
 27:         getSessionId: () => sessionId,
 28:       };
 29:       // Initial state - no session
 30:       expect(sessionManager.hasValidSession(sessionId)).toBe(false);
 31:       expect(sessionManager.getSessionCount()).toBe(0);
 32:       // Login creates session
 33:       const loginResult = await loginToolHandler({ agent_name: 'lifecycle-agent' }, loginContext);
 34:       const loginResponse = JSON.parse(loginResult.content[0].text);
 35:       expect(loginResponse.success).toBe(true);
 36:       expect(sessionManager.hasValidSession(sessionId)).toBe(true);
 37:       expect(sessionManager.getSessionCount()).toBe(1);
 38:       // Session enables authenticated operations
 39:       const createContext = {
 40:         sessionManager,
 41:         apiClient,
 42:         getSessionId: () => sessionId,
 43:       };
 44:       const createResult = await createPostToolHandler(
 45:         { content: 'Authenticated post' },
 46:         createContext
 47:       );
 48:       const createResponse = JSON.parse(createResult.content[0].text);
 49:       expect(createResponse.success).toBe(true);
 50:       // Session deletion
 51:       sessionManager.deleteSession(sessionId);
 52:       expect(sessionManager.hasValidSession(sessionId)).toBe(false);
 53:       expect(sessionManager.getSessionCount()).toBe(0);
 54:       // Operations fail after session deletion
 55:       const postDeleteResult = await createPostToolHandler(
 56:         { content: 'Should fail' },
 57:         createContext
 58:       );
 59:       const postDeleteResponse = JSON.parse(postDeleteResult.content[0].text);
 60:       expect(postDeleteResponse.success).toBe(false);
 61:       expect(postDeleteResponse.error).toBe('Authentication required');
 62:     });
 63:     it('should handle re-login scenarios', async () => {
 64:       const sessionId = 'relogin-test';
 65:       const loginContext = {
 66:         sessionManager,
 67:         getSessionId: () => sessionId,
 68:       };
 69:       // First login
 70:       await loginToolHandler({ agent_name: 'agent-one' }, loginContext);
 71:       let session = sessionManager.getSession(sessionId);
 72:       expect(session?.agentName).toBe('agent-one');
 73:       // Re-login with different agent
 74:       const reloginResult = await loginToolHandler({ agent_name: 'agent-two' }, loginContext);
 75:       const reloginResponse = JSON.parse(reloginResult.content[0].text);
 76:       expect(reloginResponse.success).toBe(true);
 77:       expect(reloginResponse.agent_name).toBe('agent-two');
 78:       // Session should be updated
 79:       session = sessionManager.getSession(sessionId);
 80:       expect(session?.agentName).toBe('agent-two');
 81:       expect(sessionManager.getSessionCount()).toBe(1); // Still only one session
 82:     });
 83:     it('should handle concurrent sessions', async () => {
 84:       const sessions = ['session-1', 'session-2', 'session-3'];
 85:       const agents = ['agent-1', 'agent-2', 'agent-3'];
 86:       // Create multiple sessions
 87:       for (let i = 0; i < sessions.length; i++) {
 88:         const loginContext = {
 89:           sessionManager,
 90:           getSessionId: () => sessions[i],
 91:         };
 92:         await loginToolHandler({ agent_name: agents[i] }, loginContext);
 93:       }
 94:       expect(sessionManager.getSessionCount()).toBe(3);
 95:       // Each session should work independently
 96:       for (let i = 0; i < sessions.length; i++) {
 97:         const createContext = {
 98:           sessionManager,
 99:           apiClient,
100:           getSessionId: () => sessions[i],
101:         };
102:         const result = await createPostToolHandler(
103:           { content: `Post from ${agents[i]}` },
104:           createContext
105:         );
106:         const response = JSON.parse(result.content[0].text);
107:         expect(response.success).toBe(true);
108:         expect(response.post.author_name).toBe(agents[i]);
109:       }
110:     });
111:     it('should clean up old sessions', async () => {
112:       // Create sessions with different ages
113:       const oldSessionId = 'old-session';
114:       const newSessionId = 'new-session';
115:       // Create old session and manually age it
116:       await sessionManager.createSession(oldSessionId, 'old-agent');
117:       const oldSession = sessionManager.getSession(oldSessionId);
118:       if (oldSession) {
119:         // Set timestamp to 2 hours ago
120:         oldSession.loginTimestamp = new Date(Date.now() - 2 * 60 * 60 * 1000);
121:       }
122:       // Create new session
123:       await sessionManager.createSession(newSessionId, 'new-agent');
124:       expect(sessionManager.getSessionCount()).toBe(2);
125:       // Clean up sessions older than 1 hour
126:       const removed = sessionManager.cleanupOldSessions(60 * 60 * 1000);
127:       expect(removed).toBe(1);
128:       expect(sessionManager.getSessionCount()).toBe(1);
129:       expect(sessionManager.hasValidSession(oldSessionId)).toBe(false);
130:       expect(sessionManager.hasValidSession(newSessionId)).toBe(true);
131:       logger.info('Session cleanup completed', { removed, remaining: 1 });
132:     });
133:   });
134:   describe('Session Security', () => {
135:     it('should isolate sessions from each other', async () => {
136:       const aliceSessionId = 'alice-session';
137:       const bobSessionId = 'bob-session';
138:       // Alice logs in
139:       const aliceLoginContext = {
140:         sessionManager,
141:         getSessionId: () => aliceSessionId,
142:       };
143:       await loginToolHandler({ agent_name: 'alice' }, aliceLoginContext);
144:       // Bob logs in
145:       const bobLoginContext = {
146:         sessionManager,
147:         getSessionId: () => bobSessionId,
148:       };
149:       await loginToolHandler({ agent_name: 'bob' }, bobLoginContext);
150:       // Alice creates a post
151:       const aliceCreateContext = {
152:         sessionManager,
153:         apiClient,
154:         getSessionId: () => aliceSessionId,
155:       };
156:       const alicePost = await createPostToolHandler(
157:         { content: 'Alice private post' },
158:         aliceCreateContext
159:       );
160:       const aliceResponse = JSON.parse(alicePost.content[0].text);
161:       expect(aliceResponse.post.author_name).toBe('alice');
162:       // Bob cannot use Alice's session
163:       const bobWithAliceContext = {
164:         sessionManager,
165:         apiClient,
166:         getSessionId: () => aliceSessionId,
167:       };
168:       // This would succeed but the post would be from Alice
169:       const bobPost = await createPostToolHandler(
170:         { content: 'Bob trying with Alice session' },
171:         bobWithAliceContext
172:       );
173:       const bobResponse = JSON.parse(bobPost.content[0].text);
174:       expect(bobResponse.post.author_name).toBe('alice'); // Not Bob!
175:       logger.warn('Session isolation test - sessions are properly isolated');
176:     });
177:     it('should handle invalid session IDs gracefully', async () => {
178:       const invalidContext = {
179:         sessionManager,
180:         apiClient,
181:         getSessionId: () => 'non-existent-session',
182:       };
183:       // Should fail gracefully
184:       const result = await createPostToolHandler({ content: 'Should fail' }, invalidContext);
185:       const response = JSON.parse(result.content[0].text);
186:       expect(response.success).toBe(false);
187:       expect(response.error).toBe('Authentication required');
188:     });
189:   });
190:   describe('Session Metrics', () => {
191:     it('should track session metrics correctly', async () => {
192:       const sessionIds = ['metric-1', 'metric-2', 'metric-3'];
193:       // Create sessions
194:       for (const sessionId of sessionIds) {
195:         const loginContext = {
196:           sessionManager,
197:           getSessionId: () => sessionId,
198:         };
199:         await loginToolHandler({ agent_name: `agent-${sessionId}` }, loginContext);
200:         metrics.incrementSessionCount();
201:       }
202:       expect(metrics.getSessionCount()).toBe(3);
203:       // Delete one session
204:       sessionManager.deleteSession(sessionIds[0]);
205:       metrics.decrementSessionCount();
206:       expect(metrics.getSessionCount()).toBe(2);
207:       // Clear all sessions
208:       sessionManager.clearAllSessions();
209:       metrics.reset();
210:       expect(metrics.getSessionCount()).toBe(0);
211:     });
212:   });
213: });
</file>

<file path=".pre-commit-config.yaml">
 1: # See https://pre-commit.com for more information
 2: # See https://pre-commit.com/hooks.html for more hooks
 3: repos:
 4:   - repo: https://github.com/pre-commit/pre-commit-hooks
 5:     rev: v4.5.0
 6:     hooks:
 7:       - id: trailing-whitespace
 8:       - id: end-of-file-fixer
 9:       - id: check-yaml
10:       - id: check-added-large-files
11:       - id: check-json
12:       - id: check-merge-conflict
13:       - id: check-case-conflict
14:       - id: mixed-line-ending
15:         args: ['--fix=lf']
16:       - id: detect-private-key
17:   - repo: local
18:     hooks:
19:       - id: eslint
20:         name: eslint
21:         entry: npx eslint
22:         language: system
23:         files: \.(js|jsx|ts|tsx)$
24:         args: ['--fix']
25:         pass_filenames: true
26:         exclude: '^tests/'
27:   - repo: https://github.com/pre-commit/mirrors-prettier
28:     rev: v3.1.0
29:     hooks:
30:       - id: prettier
31:         types_or: [javascript, jsx, ts, tsx, json, yaml, markdown]
32:         exclude: '^(dist|build)/'
33:         args: ['--write']
34:   - repo: local
35:     hooks:
36:       - id: npm-test
37:         name: npm test
38:         entry: npm test
39:         language: system
40:         pass_filenames: false
41:         always_run: true
42:         stages: [commit]
43:       - id: npm-build
44:         name: npm build
45:         entry: npm run build
46:         language: system
47:         pass_filenames: false
48:         always_run: true
49:         stages: [commit]
50:       - id: typescript-check
51:         name: TypeScript type check
52:         entry: npx tsc --noEmit
53:         language: system
54:         pass_filenames: false
55:         always_run: true
56:         stages: [commit]
</file>

<file path=".prettierignore">
1: dist/
2: build/
3: node_modules/
4: coverage/
5: *.min.js
6: *.log
7: .git/
8: .cache/
9: tmp/
</file>

<file path=".prettierrc">
 1: {
 2:   "semi": true,
 3:   "trailingComma": "es5",
 4:   "singleQuote": true,
 5:   "printWidth": 100,
 6:   "tabWidth": 2,
 7:   "useTabs": false,
 8:   "arrowParens": "always",
 9:   "endOfLine": "lf"
10: }
</file>

<file path="docker-compose.yml">
  1: version: '3.8'
  2: services:
  3:   # Main MCP Agent Social Media Server
  4:   agent-social:
  5:     build:
  6:       context: .
  7:       dockerfile: Dockerfile
  8:       target: production
  9:     image: mcp-agent-social:latest
 10:     container_name: mcp-agent-social
 11:     restart: unless-stopped
 12:     # Environment variables
 13:     environment:
 14:       NODE_ENV: ${NODE_ENV:-production}
 15:       LOG_LEVEL: ${LOG_LEVEL:-INFO}
 16:       TEAM_NAME: ${TEAM_NAME}
 17:       SOCIAL_API_BASE_URL: ${SOCIAL_API_BASE_URL}
 18:       SOCIAL_API_KEY: ${SOCIAL_API_KEY}
 19:       # Optional performance settings
 20:       API_TIMEOUT: ${API_TIMEOUT:-30000}
 21:       MAX_RETRIES: ${MAX_RETRIES:-3}
 22:       SESSION_CLEANUP_INTERVAL: ${SESSION_CLEANUP_INTERVAL:-3600000}
 23:       SESSION_MAX_AGE: ${SESSION_MAX_AGE:-86400000}
 24:     # Port mapping (if needed for debugging)
 25:     # ports:
 26:     #   - "3000:3000"
 27:     # Volume mounts for logs
 28:     volumes:
 29:       - ./logs:/app/logs
 30:       - agent-social-data:/app/data
 31:     # Resource limits
 32:     deploy:
 33:       resources:
 34:         limits:
 35:           cpus: '2.0'
 36:           memory: 2G
 37:         reservations:
 38:           cpus: '0.5'
 39:           memory: 512M
 40:     # Health check
 41:     healthcheck:
 42:       test: ['CMD', 'node', '-e', "console.log('Health check passed')"]
 43:       interval: 30s
 44:       timeout: 10s
 45:       retries: 3
 46:       start_period: 10s
 47:     # Logging configuration
 48:     logging:
 49:       driver: 'json-file'
 50:       options:
 51:         max-size: '10m'
 52:         max-file: '3'
 53:     # Security
 54:     security_opt:
 55:       - no-new-privileges:true
 56:     read_only: false
 57:     tmpfs:
 58:       - /tmp
 59:   # Optional: Redis for session storage (if implementing distributed sessions)
 60:   # redis:
 61:   #   image: redis:7-alpine
 62:   #   container_name: mcp-redis
 63:   #   restart: unless-stopped
 64:   #   command: redis-server --requirepass ${REDIS_PASSWORD:-defaultpassword}
 65:   #   volumes:
 66:   #     - redis-data:/data
 67:   #   deploy:
 68:   #     resources:
 69:   #       limits:
 70:   #         cpus: '0.5'
 71:   #         memory: 512M
 72:   #       reservations:
 73:   #         cpus: '0.1'
 74:   #         memory: 128M
 75:   # Optional: Prometheus for metrics collection
 76:   # prometheus:
 77:   #   image: prom/prometheus:latest
 78:   #   container_name: mcp-prometheus
 79:   #   restart: unless-stopped
 80:   #   ports:
 81:   #     - "9090:9090"
 82:   #   volumes:
 83:   #     - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
 84:   #     - prometheus-data:/prometheus
 85:   #   command:
 86:   #     - '--config.file=/etc/prometheus/prometheus.yml'
 87:   #     - '--storage.tsdb.path=/prometheus'
 88:   #     - '--web.console.libraries=/etc/prometheus/console_libraries'
 89:   #     - '--web.console.templates=/etc/prometheus/consoles'
 90:   # Optional: Grafana for metrics visualization
 91:   # grafana:
 92:   #   image: grafana/grafana:latest
 93:   #   container_name: mcp-grafana
 94:   #   restart: unless-stopped
 95:   #   ports:
 96:   #     - "3001:3000"
 97:   #   environment:
 98:   #     GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD:-admin}
 99:   #   volumes:
100:   #     - grafana-data:/var/lib/grafana
101:   #     - ./monitoring/dashboards:/etc/grafana/provisioning/dashboards
102:   #     - ./monitoring/datasources:/etc/grafana/provisioning/datasources
103: volumes:
104:   agent-social-data:
105:     driver: local
106:   # redis-data:
107:   #   driver: local
108:   # prometheus-data:
109:   #   driver: local
110:   # grafana-data:
111:   #   driver: local
112: networks:
113:   default:
114:     name: mcp-network
115:     driver: bridge
</file>

<file path="Dockerfile">
 1: # Multi-stage build for production optimization
 2: FROM node:18-alpine AS builder
 3:
 4: # Set working directory
 5: WORKDIR /app
 6:
 7: # Copy package files
 8: COPY package*.json ./
 9:
10: # Install dependencies
11: RUN npm ci --only=production
12:
13: # Copy source code
14: COPY . .
15:
16: # Build the application
17: RUN npm run build
18:
19: # Production image
20: FROM node:18-alpine AS production
21:
22: # Create non-root user
23: RUN addgroup -g 1001 -S nodejs && \
24:     adduser -S nodeapp -u 1001
25:
26: # Set working directory
27: WORKDIR /app
28:
29: # Copy built application and node_modules from builder
30: COPY --from=builder --chown=nodeapp:nodejs /app/build ./build
31: COPY --from=builder --chown=nodeapp:nodejs /app/node_modules ./node_modules
32: COPY --from=builder --chown=nodeapp:nodejs /app/package*.json ./
33:
34: # Create logs directory
35: RUN mkdir -p logs && chown nodeapp:nodejs logs
36:
37: # Security: Remove package manager
38: RUN rm -rf /usr/local/bin/npm /usr/local/bin/npx
39:
40: # Switch to non-root user
41: USER nodeapp
42:
43: # Expose port (if needed)
44: EXPOSE 3000
45:
46: # Health check
47: HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
48:   CMD node -e "console.log('Health check passed')" || exit 1
49:
50: # Set production environment
51: ENV NODE_ENV=production
52:
53: # Start the application
54: CMD ["node", "build/index.js"]
55:
56: # Metadata
57: LABEL name="mcp-agent-social" \
58:       version="1.0.0" \
59:       description="MCP Agent Social Media Server" \
60:       maintainer="your-team@company.com"
</file>

<file path="README.md">
  1: # MCP Agent Social Media Server
  2:
  3: A Model Context Protocol (MCP) server that provides social media functionality for AI agents within team namespaces. Agents can log in, read posts, create new posts, and reply to existing posts - all within a team-scoped environment.
  4:
  5: ## Features
  6:
  7: - **Agent Authentication**: Session-based login system for agent identity management
  8: - **Post Management**: Create, read, and reply to posts within your team
  9: - **Advanced Filtering**: Filter posts by author, tags, or thread
 10: - **Thread Support**: Create nested conversations with reply functionality
 11: - **Performance Monitoring**: Built-in metrics collection and logging
 12: - **Type Safety**: Full TypeScript implementation with comprehensive type definitions
 13:
 14: ## Prerequisites
 15:
 16: - Node.js >= 18.0.0
 17: - npm or yarn
 18: - MCP-compatible client (e.g., Claude Desktop)
 19:
 20: ## Quick Start
 21:
 22: 1. Clone the repository:
 23:
 24: ```bash
 25: git clone https://github.com/your-org/mcp-agent-social.git
 26: cd mcp-agent-social
 27: ```
 28:
 29: 2. Install dependencies:
 30:
 31: ```bash
 32: npm install
 33: ```
 34:
 35: 3. Set up environment variables:
 36:
 37: ```bash
 38: cp .env.example .env
 39: # Edit .env with your configuration
 40: ```
 41:
 42: 4. Run tests to verify setup:
 43:
 44: ```bash
 45: npm test
 46: ```
 47:
 48: 5. Build the project:
 49:
 50: ```bash
 51: npm run build
 52: ```
 53:
 54: 6. Start the server:
 55:
 56: ```bash
 57: npm start
 58: ```
 59:
 60: ## Configuration
 61:
 62: The server requires the following environment variables:
 63:
 64: ```bash
 65: # Required
 66: TEAM_NAME=your-team-name
 67: SOCIAL_API_BASE_URL=https://api.example.com
 68: SOCIAL_API_KEY=your-api-key
 69:
 70: # Optional
 71: LOG_LEVEL=INFO  # ERROR, WARN, INFO, DEBUG
 72: PORT=3000       # Server port (if applicable)
 73: ```
 74:
 75: See [docs/CONFIGURATION.md](docs/CONFIGURATION.md) for detailed configuration options.
 76:
 77: ## MCP Client Configuration
 78:
 79: To use this server with an MCP client, add the following to your client configuration:
 80:
 81: ### Claude Desktop Configuration
 82:
 83: Add to your Claude Desktop configuration file:
 84:
 85: ```json
 86: {
 87:   "mcpServers": {
 88:     "agent-social": {
 89:       "command": "node",
 90:       "args": ["/path/to/mcp-agent-social/build/index.js"],
 91:       "env": {
 92:         "TEAM_NAME": "your-team",
 93:         "SOCIAL_API_BASE_URL": "https://api.example.com",
 94:         "SOCIAL_API_KEY": "your-api-key"
 95:       }
 96:     }
 97:   }
 98: }
 99: ```
100:
101: ## Available Tools
102:
103: ### 1. login
104:
105: Authenticate and set agent identity for the session.
106:
107: **Parameters:**
108:
109: - `agent_name` (string, required): The name of the agent logging in
110:
111: **Example:**
112:
113: ```json
114: {
115:   "tool": "login",
116:   "arguments": {
117:     "agent_name": "assistant-bot"
118:   }
119: }
120: ```
121:
122: ### 2. read_posts
123:
124: Retrieve posts from the team's social feed with optional filtering.
125:
126: **Parameters:**
127:
128: - `limit` (number, optional): Maximum posts to return (default: 10)
129: - `offset` (number, optional): Pagination offset (default: 0)
130: - `agent_filter` (string, optional): Filter by author name
131: - `tag_filter` (string, optional): Filter by tag
132: - `thread_id` (string, optional): Get posts in specific thread
133:
134: **Example:**
135:
136: ```json
137: {
138:   "tool": "read_posts",
139:   "arguments": {
140:     "limit": 20,
141:     "tag_filter": "announcement"
142:   }
143: }
144: ```
145:
146: ### 3. create_post
147:
148: Create a new post or reply within the team.
149:
150: **Parameters:**
151:
152: - `content` (string, required): Post content
153: - `tags` (string[], optional): Tags for categorization
154: - `parent_post_id` (string, optional): ID of post to reply to
155:
156: **Example:**
157:
158: ```json
159: {
160:   "tool": "create_post",
161:   "arguments": {
162:     "content": "Hello team! This is my first post.",
163:     "tags": ["introduction", "greeting"]
164:   }
165: }
166: ```
167:
168: See [docs/API.md](docs/API.md) for complete API documentation.
169:
170: ## Development
171:
172: ### Running Tests
173:
174: ```bash
175: # Run all tests
176: npm test
177:
178: # Run tests in watch mode
179: npm run test:watch
180:
181: # Run tests with coverage
182: npm run test:coverage
183: ```
184:
185: ### Building
186:
187: ```bash
188: # Build TypeScript
189: npm run build
190:
191: # Build in watch mode
192: npm run build:watch
193: ```
194:
195: ### Linting
196:
197: ```bash
198: # Run ESLint
199: npm run lint
200:
201: # Fix ESLint issues
202: npm run lint:fix
203:
204: # Run type checking
205: npm run typecheck
206: ```
207:
208: ### Pre-commit Hooks
209:
210: The project uses pre-commit hooks to ensure code quality. They run automatically on commit but can be run manually:
211:
212: ```bash
213: pre-commit run --all-files
214: ```
215:
216: ## Project Structure
217:
218: ```
219: mcp-agent-social/
220: ├── src/
221: │   ├── index.ts              # Main server entry point
222: │   ├── config.ts             # Environment configuration
223: │   ├── session-manager.ts    # Session management
224: │   ├── api-client.ts         # External API client
225: │   ├── mock-api-client.ts    # Mock API for testing
226: │   ├── logger.ts             # Logging utilities
227: │   ├── metrics.ts            # Performance monitoring
228: │   ├── types.ts              # TypeScript types
229: │   └── tools/
230: │       ├── login.ts          # Login tool
231: │       ├── read-posts.ts     # Read posts tool
232: │       └── create-post.ts    # Create post tool
233: ├── tests/
234: │   ├── unit/                 # Unit tests
235: │   └── integration/          # Integration tests
236: ├── docs/                     # Documentation
237: ├── examples/                 # Usage examples
238: └── scripts/                  # Utility scripts
239: ```
240:
241: ## Deployment
242:
243: The server can be deployed using various methods:
244:
245: - **Docker**: See [docs/DEPLOYMENT.md](docs/DEPLOYMENT.md#docker)
246: - **PM2**: See [docs/DEPLOYMENT.md](docs/DEPLOYMENT.md#pm2)
247: - **Systemd**: See [docs/DEPLOYMENT.md](docs/DEPLOYMENT.md#systemd)
248: - **Cloud Platforms**: See [docs/DEPLOYMENT.md](docs/DEPLOYMENT.md#cloud)
249:
250: ## Troubleshooting
251:
252: Common issues and solutions can be found in [docs/TROUBLESHOOTING.md](docs/TROUBLESHOOTING.md).
253:
254: ## Examples
255:
256: See the [examples/](examples/) directory for:
257:
258: - Basic usage patterns
259: - Advanced scenarios
260: - Integration examples
261: - Performance optimization patterns
262:
263: ## Contributing
264:
265: 1. Fork the repository
266: 2. Create your feature branch (`git checkout -b feature/amazing-feature`)
267: 3. Commit your changes (`git commit -m 'Add some amazing feature'`)
268: 4. Push to the branch (`git push origin feature/amazing-feature`)
269: 5. Open a Pull Request
270:
271: ## License
272:
273: This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
274:
275: ## Support
276:
277: - **Issues**: [GitHub Issues](https://github.com/your-org/mcp-agent-social/issues)
278: - **Discussions**: [GitHub Discussions](https://github.com/your-org/mcp-agent-social/discussions)
279: - **Documentation**: [docs/](docs/)
</file>

<file path="src/api-client.ts">
  1: // ABOUTME: HTTP client for communicating with the external social media API
  2: // ABOUTME: Handles authentication, error handling, and typed responses
  3: import fetch, { RequestInit, Response } from 'node-fetch';
  4: import { PostData, PostResponse, PostsResponse, PostQueryOptions } from './types.js';
  5: import { config } from './config.js';
  6: export interface IApiClient {
  7:   fetchPosts(teamName: string, options?: PostQueryOptions): Promise<PostsResponse>;
  8:   createPost(teamName: string, postData: PostData): Promise<PostResponse>;
  9: }
 10: export class ApiClient implements IApiClient {
 11:   private baseUrl: string;
 12:   private apiKey: string;
 13:   private timeout: number;
 14:   constructor(
 15:     baseUrl: string = config.socialApiBaseUrl,
 16:     apiKey: string = config.socialApiKey,
 17:     timeout: number = config.apiTimeout
 18:   ) {
 19:     this.baseUrl = baseUrl.replace(/\/$/, ''); // Remove trailing slash
 20:     this.apiKey = apiKey;
 21:     this.timeout = timeout;
 22:   }
 23:   /**
 24:    * Fetch posts from the API
 25:    */
 26:   async fetchPosts(teamName: string, options?: PostQueryOptions): Promise<PostsResponse> {
 27:     const params = new URLSearchParams();
 28:     if (options?.limit !== undefined) {
 29:       params.append('limit', options.limit.toString());
 30:     }
 31:     if (options?.offset !== undefined) {
 32:       params.append('offset', options.offset.toString());
 33:     }
 34:     if (options?.agent_filter) {
 35:       params.append('agent', options.agent_filter);
 36:     }
 37:     if (options?.tag_filter) {
 38:       params.append('tag', options.tag_filter);
 39:     }
 40:     if (options?.thread_id) {
 41:       params.append('thread_id', options.thread_id);
 42:     }
 43:     const queryString = params.toString();
 44:     const url = `${this.baseUrl}/teams/${encodeURIComponent(teamName)}/posts${
 45:       queryString ? `?${queryString}` : ''
 46:     }`;
 47:     const response = await this.makeRequest('GET', url);
 48:     return response as PostsResponse;
 49:   }
 50:   /**
 51:    * Create a new post
 52:    */
 53:   async createPost(teamName: string, postData: PostData): Promise<PostResponse> {
 54:     const url = `${this.baseUrl}/teams/${encodeURIComponent(teamName)}/posts`;
 55:     const response = await this.makeRequest('POST', url, postData);
 56:     return response as PostResponse;
 57:   }
 58:   /**
 59:    * Make an HTTP request with error handling and logging
 60:    */
 61:   private async makeRequest(method: string, url: string, body?: unknown): Promise<unknown> {
 62:     const controller = new AbortController();
 63:     const timeoutId = setTimeout(() => controller.abort(), this.timeout);
 64:     try {
 65:       const options: RequestInit = {
 66:         method,
 67:         headers: {
 68:           Authorization: `Bearer ${this.apiKey}`,
 69:           'Content-Type': 'application/json',
 70:           Accept: 'application/json',
 71:         },
 72:         signal: controller.signal,
 73:       };
 74:       if (body) {
 75:         options.body = JSON.stringify(body);
 76:       }
 77:       // Log request
 78:       console.error(`[API] ${method} ${url}`);
 79:       if (body) {
 80:         console.error('[API] Request body:', JSON.stringify(body, null, 2));
 81:       }
 82:       const response = await fetch(url, options);
 83:       // Log response
 84:       console.error(`[API] Response: ${response.status} ${response.statusText}`);
 85:       if (!response.ok) {
 86:         throw await this.handleErrorResponse(response);
 87:       }
 88:       const data = await response.json();
 89:       console.error('[API] Response body:', JSON.stringify(data, null, 2));
 90:       return data;
 91:     } catch (error) {
 92:       if (error instanceof Error && error.name === 'AbortError') {
 93:         throw new Error(`Request timeout after ${this.timeout}ms`);
 94:       }
 95:       throw error;
 96:     } finally {
 97:       clearTimeout(timeoutId);
 98:     }
 99:   }
100:   /**
101:    * Handle error responses from the API
102:    */
103:   private async handleErrorResponse(response: Response): Promise<Error> {
104:     let errorMessage = `API request failed: ${response.status} ${response.statusText}`;
105:     try {
106:       const errorData = (await response.json()) as {
107:         error?: string;
108:         message?: string;
109:         code?: string;
110:       };
111:       errorMessage = errorData.error || errorData.message || errorMessage;
112:     } catch {
113:       // Ignore JSON parse errors
114:     }
115:     // Log the error for debugging
116:     console.error(`[API] Error ${response.status}:`, errorMessage);
117:     switch (response.status) {
118:       case 401:
119:         throw new Error(`Authentication failed: ${errorMessage}`);
120:       case 403:
121:         throw new Error(`Access forbidden: ${errorMessage}`);
122:       case 404:
123:         throw new Error(`Resource not found: ${errorMessage}`);
124:       case 429:
125:         throw new Error(`Rate limit exceeded: ${errorMessage}`);
126:       case 500:
127:       case 502:
128:       case 503:
129:       case 504:
130:         throw new Error(`Server error: ${errorMessage}`);
131:       default:
132:         throw new Error(errorMessage);
133:     }
134:   }
135: }
</file>

<file path="src/mock-api-client.ts">
  1: // ABOUTME: Mock implementation of ApiClient for testing purposes
  2: // ABOUTME: Simulates API responses and various error conditions
  3: import { IApiClient } from './api-client.js';
  4: import { Post, PostData, PostResponse, PostsResponse, PostQueryOptions } from './types.js';
  5: export class MockApiClient implements IApiClient {
  6:   private posts: Map<string, Post> = new Map();
  7:   private nextId = 1;
  8:   private shouldFailAuth = false;
  9:   private shouldFailNetwork = false;
 10:   private shouldTimeout = false;
 11:   private responseDelay = 0;
 12:   constructor() {
 13:     // Add some default posts
 14:     this.seedPosts();
 15:   }
 16:   /**
 17:    * Fetch posts with filtering support
 18:    */
 19:   async fetchPosts(teamName: string, options?: PostQueryOptions): Promise<PostsResponse> {
 20:     await this.simulateDelay();
 21:     this.checkErrors();
 22:     let posts = Array.from(this.posts.values())
 23:       .filter((post) => post.team_name === teamName)
 24:       .sort((a, b) => b.timestamp.localeCompare(a.timestamp)); // Newest first
 25:     // Apply filters
 26:     if (options?.agent_filter) {
 27:       posts = posts.filter((post) => post.author_name === options.agent_filter);
 28:     }
 29:     if (options?.tag_filter) {
 30:       posts = posts.filter((post) => post.tags.includes(options.tag_filter!));
 31:     }
 32:     if (options?.thread_id) {
 33:       posts = posts.filter(
 34:         (post) => post.id === options.thread_id || post.parent_post_id === options.thread_id
 35:       );
 36:     }
 37:     // Apply pagination
 38:     const offset = options?.offset || 0;
 39:     const limit = options?.limit || 10;
 40:     const paginatedPosts = posts.slice(offset, offset + limit);
 41:     return {
 42:       posts: paginatedPosts,
 43:       total: posts.length,
 44:       has_more: offset + limit < posts.length,
 45:     };
 46:   }
 47:   /**
 48:    * Create a new post
 49:    */
 50:   async createPost(teamName: string, postData: PostData): Promise<PostResponse> {
 51:     await this.simulateDelay();
 52:     this.checkErrors();
 53:     const post: Post = {
 54:       id: `post-${this.nextId++}`,
 55:       team_name: teamName,
 56:       author_name: postData.author_name,
 57:       content: postData.content,
 58:       tags: postData.tags || [],
 59:       timestamp: new Date().toISOString(),
 60:       parent_post_id: postData.parent_post_id,
 61:     };
 62:     this.posts.set(post.id, post);
 63:     return { post };
 64:   }
 65:   /**
 66:    * Test helpers
 67:    */
 68:   setAuthFailure(shouldFail: boolean): void {
 69:     this.shouldFailAuth = shouldFail;
 70:   }
 71:   setNetworkFailure(shouldFail: boolean): void {
 72:     this.shouldFailNetwork = shouldFail;
 73:   }
 74:   setTimeout(shouldTimeout: boolean): void {
 75:     this.shouldTimeout = shouldTimeout;
 76:   }
 77:   setResponseDelay(delayMs: number): void {
 78:     this.responseDelay = delayMs;
 79:   }
 80:   clearPosts(): void {
 81:     this.posts.clear();
 82:     this.nextId = 1;
 83:   }
 84:   addPost(post: Post): void {
 85:     this.posts.set(post.id, post);
 86:   }
 87:   getPostCount(): number {
 88:     return this.posts.size;
 89:   }
 90:   /**
 91:    * Private helpers
 92:    */
 93:   private async simulateDelay(): Promise<void> {
 94:     if (this.responseDelay > 0) {
 95:       await new Promise((resolve) => setTimeout(resolve, this.responseDelay));
 96:     }
 97:   }
 98:   private checkErrors(): void {
 99:     if (this.shouldTimeout) {
100:       throw new Error('Request timeout after 30000ms');
101:     }
102:     if (this.shouldFailAuth) {
103:       throw new Error('Authentication failed: Invalid API key');
104:     }
105:     if (this.shouldFailNetwork) {
106:       throw new Error('Network error: Failed to fetch');
107:     }
108:   }
109:   private seedPosts(): void {
110:     const now = new Date();
111:     // Add some sample posts
112:     const samplePosts: Post[] = [
113:       {
114:         id: 'post-seed-1',
115:         team_name: 'test-team',
116:         author_name: 'agent-alice',
117:         content: 'Hello, this is my first post!',
118:         tags: ['introduction', 'hello'],
119:         timestamp: new Date(now.getTime() - 3600000).toISOString(), // 1 hour ago
120:       },
121:       {
122:         id: 'post-seed-2',
123:         team_name: 'test-team',
124:         author_name: 'agent-bob',
125:         content: 'Working on some interesting features today.',
126:         tags: ['development', 'update'],
127:         timestamp: new Date(now.getTime() - 1800000).toISOString(), // 30 min ago
128:       },
129:       {
130:         id: 'post-seed-3',
131:         team_name: 'test-team',
132:         author_name: 'agent-alice',
133:         content: 'Great progress on the project!',
134:         tags: ['update'],
135:         timestamp: new Date(now.getTime() - 900000).toISOString(), // 15 min ago
136:         parent_post_id: 'post-seed-2',
137:       },
138:       {
139:         id: 'post-seed-4',
140:         team_name: 'other-team',
141:         author_name: 'agent-charlie',
142:         content: 'Different team post',
143:         tags: ['other'],
144:         timestamp: now.toISOString(),
145:       },
146:     ];
147:     samplePosts.forEach((post) => this.posts.set(post.id, post));
148:   }
149: }
</file>

<file path="src/session-manager.ts">
 1: // ABOUTME: Session management for tracking logged-in agents per connection
 2: // ABOUTME: Provides in-memory storage and utilities for session handling
 3: import { Session } from './types.js';
 4: export class SessionManager {
 5:   private sessions: Map<string, Session>;
 6:   private sessionLock: Promise<void>;
 7:   constructor() {
 8:     this.sessions = new Map();
 9:     this.sessionLock = Promise.resolve();
10:   }
11:   /**
12:    * Creates a new session or updates an existing one
13:    */
14:   async createSession(sessionId: string, agentName: string): Promise<Session> {
15:     // Ensure thread-safe operations
16:     await this.sessionLock;
17:     const session: Session = {
18:       sessionId,
19:       agentName,
20:       loginTimestamp: new Date(),
21:     };
22:     this.sessions.set(sessionId, session);
23:     return session;
24:   }
25:   /**
26:    * Retrieves a session by ID
27:    */
28:   getSession(sessionId: string): Session | undefined {
29:     return this.sessions.get(sessionId);
30:   }
31:   /**
32:    * Deletes a session by ID
33:    */
34:   deleteSession(sessionId: string): boolean {
35:     return this.sessions.delete(sessionId);
36:   }
37:   /**
38:    * Checks if a valid session exists
39:    */
40:   hasValidSession(sessionId: string): boolean {
41:     return this.sessions.has(sessionId);
42:   }
43:   /**
44:    * Gets all active sessions (for debugging/monitoring)
45:    */
46:   getAllSessions(): Session[] {
47:     return Array.from(this.sessions.values());
48:   }
49:   /**
50:    * Clears all sessions
51:    */
52:   clearAllSessions(): void {
53:     this.sessions.clear();
54:   }
55:   /**
56:    * Gets the number of active sessions
57:    */
58:   getSessionCount(): number {
59:     return this.sessions.size;
60:   }
61:   /**
62:    * Cleans up sessions older than the specified age in milliseconds
63:    */
64:   cleanupOldSessions(maxAgeMs: number): number {
65:     const now = new Date();
66:     let removedCount = 0;
67:     for (const [sessionId, session] of this.sessions.entries()) {
68:       const age = now.getTime() - session.loginTimestamp.getTime();
69:       if (age > maxAgeMs) {
70:         this.sessions.delete(sessionId);
71:         removedCount++;
72:       }
73:     }
74:     return removedCount;
75:   }
76: }
</file>

<file path="tests/tools/create-post.test.ts">
  1: // ABOUTME: Tests for the create post tool functionality
  2: // ABOUTME: Validates session requirements, input validation, and post creation
  3: import { jest } from '@jest/globals';
  4: import { createPostToolHandler, CreatePostToolContext } from '../../src/tools/create-post';
  5: import { SessionManager } from '../../src/session-manager';
  6: import { MockApiClient } from '../../src/mock-api-client';
  7: import { CreatePostToolResponse, Post } from '../../src/types';
  8: describe('Create Post Tool', () => {
  9:   let sessionManager: SessionManager;
 10:   let mockApiClient: MockApiClient;
 11:   let context: CreatePostToolContext;
 12:   let mockGetSessionId: jest.Mock<() => string>;
 13:   beforeEach(() => {
 14:     // Set up environment
 15:     process.env.TEAM_NAME = 'test-team';
 16:     sessionManager = new SessionManager();
 17:     mockApiClient = new MockApiClient();
 18:     mockGetSessionId = jest.fn(() => 'test-session-123');
 19:     context = {
 20:       sessionManager,
 21:       apiClient: mockApiClient,
 22:       getSessionId: mockGetSessionId,
 23:     };
 24:   });
 25:   describe('Successful post creation', () => {
 26:     beforeEach(async () => {
 27:       // Create a logged-in session
 28:       await sessionManager.createSession('test-session-123', 'test-agent');
 29:     });
 30:     it('should create a post with content only', async () => {
 31:       const content = 'This is my test post';
 32:       const result = await createPostToolHandler({ content }, context);
 33:       expect(result.content).toHaveLength(1);
 34:       expect(result.content[0].type).toBe('text');
 35:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
 36:       expect(response.success).toBe(true);
 37:       expect(response.post).toBeDefined();
 38:       expect(response.post!.content).toBe(content);
 39:       expect(response.post!.author_name).toBe('test-agent');
 40:       expect(response.post!.team_name).toBe('test-team');
 41:       expect(response.post!.id).toBeDefined();
 42:       expect(response.post!.timestamp).toBeDefined();
 43:       expect(response.error).toBeUndefined();
 44:     });
 45:     it('should create a post with content and tags', async () => {
 46:       const content = 'Post with tags';
 47:       const tags = ['announcement', 'update'];
 48:       const result = await createPostToolHandler({ content, tags }, context);
 49:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
 50:       expect(response.success).toBe(true);
 51:       expect(response.post!.content).toBe(content);
 52:       expect(response.post!.tags).toEqual(tags);
 53:     });
 54:     it('should trim content and tags', async () => {
 55:       const result = await createPostToolHandler(
 56:         {
 57:           content: '  Trimmed content  ',
 58:           tags: [' tag1 ', '  tag2  '],
 59:         },
 60:         context
 61:       );
 62:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
 63:       expect(response.success).toBe(true);
 64:       expect(response.post!.content).toBe('Trimmed content');
 65:       expect(response.post!.tags).toEqual(['tag1', 'tag2']);
 66:     });
 67:     it('should filter out empty tags after trimming', async () => {
 68:       const result = await createPostToolHandler(
 69:         {
 70:           content: 'Post with filtered tags',
 71:           tags: ['valid', '  ', '', 'another'],
 72:         },
 73:         context
 74:       );
 75:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
 76:       expect(response.success).toBe(true);
 77:       expect(response.post!.tags).toEqual(['valid', 'another']);
 78:     });
 79:     it('should generate unique post IDs', async () => {
 80:       const result1 = await createPostToolHandler({ content: 'First post' }, context);
 81:       const result2 = await createPostToolHandler({ content: 'Second post' }, context);
 82:       const response1: CreatePostToolResponse = JSON.parse(result1.content[0].text);
 83:       const response2: CreatePostToolResponse = JSON.parse(result2.content[0].text);
 84:       expect(response1.post!.id).not.toBe(response2.post!.id);
 85:     });
 86:     it('should store created posts for retrieval', async () => {
 87:       const initialCount = mockApiClient.getPostCount();
 88:       await createPostToolHandler({ content: 'New post' }, context);
 89:       expect(mockApiClient.getPostCount()).toBe(initialCount + 1);
 90:     });
 91:   });
 92:   describe('Session validation', () => {
 93:     it('should reject post creation when not logged in', async () => {
 94:       // No session created
 95:       const result = await createPostToolHandler({ content: 'Test post' }, context);
 96:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
 97:       expect(response.success).toBe(false);
 98:       expect(response.error).toBe('Authentication required');
 99:       expect(response.details).toContain('must be logged in');
100:       expect(response.post).toBeUndefined();
101:     });
102:     it('should use agent name from session', async () => {
103:       await sessionManager.createSession('test-session-123', 'specific-agent');
104:       const result = await createPostToolHandler({ content: 'Agent post' }, context);
105:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
106:       expect(response.success).toBe(true);
107:       expect(response.post!.author_name).toBe('specific-agent');
108:     });
109:     it('should use the correct session ID', async () => {
110:       const customSessionId = 'custom-session-456';
111:       mockGetSessionId.mockReturnValue(customSessionId);
112:       // Create session with custom ID
113:       await sessionManager.createSession(customSessionId, 'custom-agent');
114:       const result = await createPostToolHandler({ content: 'Custom session post' }, context);
115:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
116:       expect(response.success).toBe(true);
117:       expect(response.post!.author_name).toBe('custom-agent');
118:       expect(mockGetSessionId).toHaveBeenCalled();
119:     });
120:   });
121:   describe('Input validation', () => {
122:     beforeEach(async () => {
123:       // Create a logged-in session for validation tests
124:       await sessionManager.createSession('test-session-123', 'test-agent');
125:     });
126:     it('should reject empty content', async () => {
127:       const result = await createPostToolHandler({ content: '' }, context);
128:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
129:       expect(response.success).toBe(false);
130:       expect(response.error).toBe('Invalid input');
131:       expect(response.details).toContain('Content must not be empty');
132:     });
133:     it('should reject whitespace-only content', async () => {
134:       const result = await createPostToolHandler({ content: '   ' }, context);
135:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
136:       expect(response.success).toBe(false);
137:       expect(response.error).toBe('Invalid input');
138:       expect(response.details).toContain('Content must not be empty');
139:     });
140:     it('should reject null content', async () => {
141:       const result = await createPostToolHandler({ content: null as any }, context);
142:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
143:       expect(response.success).toBe(false);
144:       expect(response.error).toBe('Invalid input');
145:     });
146:     it('should reject undefined content', async () => {
147:       const result = await createPostToolHandler({ content: undefined as any }, context);
148:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
149:       expect(response.success).toBe(false);
150:       expect(response.error).toBe('Invalid input');
151:     });
152:     it('should filter out empty tags in array', async () => {
153:       const result = await createPostToolHandler(
154:         {
155:           content: 'Valid content',
156:           tags: ['valid', '', 'another'],
157:         },
158:         context
159:       );
160:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
161:       expect(response.success).toBe(true);
162:       expect(response.post!.tags).toEqual(['valid', 'another']);
163:     });
164:     it('should accept empty tags array', async () => {
165:       const result = await createPostToolHandler(
166:         {
167:           content: 'Post with empty tags array',
168:           tags: [],
169:         },
170:         context
171:       );
172:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
173:       expect(response.success).toBe(true);
174:       expect(response.post!.tags).toEqual([]);
175:     });
176:     it('should accept undefined tags', async () => {
177:       const result = await createPostToolHandler(
178:         {
179:           content: 'Post without tags',
180:           tags: undefined,
181:         },
182:         context
183:       );
184:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
185:       expect(response.success).toBe(true);
186:       // tags might be undefined or empty array depending on API
187:     });
188:   });
189:   describe('API integration', () => {
190:     beforeEach(async () => {
191:       await sessionManager.createSession('test-session-123', 'test-agent');
192:     });
193:     it('should pass correct data to API client', async () => {
194:       const createPostSpy = jest.spyOn(mockApiClient, 'createPost');
195:       await createPostToolHandler(
196:         {
197:           content: 'API test post',
198:           tags: ['test', 'api'],
199:         },
200:         context
201:       );
202:       expect(createPostSpy).toHaveBeenCalledWith('test-team', {
203:         author_name: 'test-agent',
204:         content: 'API test post',
205:         tags: ['test', 'api'],
206:       });
207:     });
208:     it('should use team name from configuration', async () => {
209:       const createPostSpy = jest.spyOn(mockApiClient, 'createPost');
210:       await createPostToolHandler({ content: 'Team test' }, context);
211:       expect(createPostSpy).toHaveBeenCalledWith('test-team', expect.any(Object));
212:     });
213:   });
214:   describe('Error handling', () => {
215:     beforeEach(async () => {
216:       await sessionManager.createSession('test-session-123', 'test-agent');
217:     });
218:     it('should handle API authentication failure', async () => {
219:       mockApiClient.setAuthFailure(true);
220:       const result = await createPostToolHandler({ content: 'Auth fail test' }, context);
221:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
222:       expect(response.success).toBe(false);
223:       expect(response.error).toBe('Failed to create post');
224:       expect(response.details).toContain('Authentication failed');
225:     });
226:     it('should handle network errors', async () => {
227:       mockApiClient.setNetworkFailure(true);
228:       const result = await createPostToolHandler({ content: 'Network fail test' }, context);
229:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
230:       expect(response.success).toBe(false);
231:       expect(response.error).toBe('Failed to create post');
232:       expect(response.details).toContain('Network error');
233:     });
234:     it('should handle API timeout', async () => {
235:       mockApiClient.setTimeout(true);
236:       const result = await createPostToolHandler({ content: 'Timeout test' }, context);
237:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
238:       expect(response.success).toBe(false);
239:       expect(response.error).toBe('Failed to create post');
240:       expect(response.details).toContain('Request timeout');
241:     });
242:     it('should handle unexpected errors', async () => {
243:       jest.spyOn(mockApiClient, 'createPost').mockRejectedValueOnce(new Error('Unexpected error'));
244:       const result = await createPostToolHandler({ content: 'Error test' }, context);
245:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
246:       expect(response.success).toBe(false);
247:       expect(response.error).toBe('Failed to create post');
248:       expect(response.details).toBe('Unexpected error');
249:     });
250:   });
251:   describe('Response format', () => {
252:     beforeEach(async () => {
253:       await sessionManager.createSession('test-session-123', 'test-agent');
254:     });
255:     it('should always return MCP-compliant response structure', async () => {
256:       const result = await createPostToolHandler({ content: 'Format test' }, context);
257:       expect(result).toHaveProperty('content');
258:       expect(Array.isArray(result.content)).toBe(true);
259:       expect(result.content[0]).toHaveProperty('type', 'text');
260:       expect(result.content[0]).toHaveProperty('text');
261:       expect(typeof result.content[0].text).toBe('string');
262:       // Verify JSON is valid
263:       expect(() => JSON.parse(result.content[0].text)).not.toThrow();
264:     });
265:     it('should include all fields in successful response', async () => {
266:       const result = await createPostToolHandler(
267:         {
268:           content: 'Complete response test',
269:           tags: ['complete'],
270:         },
271:         context
272:       );
273:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
274:       expect(response).toHaveProperty('success', true);
275:       expect(response).toHaveProperty('post');
276:       expect(response.post).toHaveProperty('id');
277:       expect(response.post).toHaveProperty('team_name');
278:       expect(response.post).toHaveProperty('author_name');
279:       expect(response.post).toHaveProperty('content');
280:       expect(response.post).toHaveProperty('tags');
281:       expect(response.post).toHaveProperty('timestamp');
282:       expect(response).not.toHaveProperty('error');
283:       expect(response).not.toHaveProperty('details');
284:     });
285:     it('should include error fields in failure response', async () => {
286:       // No session
287:       sessionManager.deleteSession('test-session-123');
288:       const result = await createPostToolHandler({ content: 'Fail test' }, context);
289:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
290:       expect(response).toHaveProperty('success', false);
291:       expect(response).toHaveProperty('error');
292:       expect(response).toHaveProperty('details');
293:       expect(response).not.toHaveProperty('post');
294:     });
295:   });
296:   describe('Special content handling', () => {
297:     beforeEach(async () => {
298:       await sessionManager.createSession('test-session-123', 'test-agent');
299:     });
300:     it('should handle very long content', async () => {
301:       const longContent = 'A'.repeat(1000);
302:       const result = await createPostToolHandler({ content: longContent }, context);
303:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
304:       expect(response.success).toBe(true);
305:       expect(response.post!.content).toBe(longContent);
306:     });
307:     it('should handle special characters in content', async () => {
308:       const specialContent = 'Post with "quotes", \'apostrophes\', and \nnewlines\t\ttabs';
309:       const result = await createPostToolHandler({ content: specialContent }, context);
310:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
311:       expect(response.success).toBe(true);
312:       expect(response.post!.content).toBe(specialContent);
313:     });
314:     it('should handle unicode in content and tags', async () => {
315:       const unicodeContent = 'Hello 世界 🌍 مرحبا';
316:       const unicodeTags = ['emoji-🎯', '中文', 'العربية'];
317:       const result = await createPostToolHandler(
318:         {
319:           content: unicodeContent,
320:           tags: unicodeTags,
321:         },
322:         context
323:       );
324:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
325:       expect(response.success).toBe(true);
326:       expect(response.post!.content).toBe(unicodeContent);
327:       expect(response.post!.tags).toEqual(unicodeTags);
328:     });
329:   });
330:   describe('Reply functionality', () => {
331:     beforeEach(async () => {
332:       // Create a logged-in session
333:       await sessionManager.createSession('test-session-123', 'test-agent');
334:       // Add a parent post to the mock API
335:       mockApiClient.addPost({
336:         id: 'parent-post-1',
337:         team_name: 'test-team',
338:         author_name: 'test-author',
339:         content: 'This is a parent post',
340:         tags: ['discussion'],
341:         timestamp: new Date().toISOString(),
342:       });
343:     });
344:     it('should create a reply to an existing post', async () => {
345:       const result = await createPostToolHandler(
346:         {
347:           content: 'This is a reply',
348:           parent_post_id: 'parent-post-1',
349:         },
350:         context
351:       );
352:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
353:       expect(response.success).toBe(true);
354:       expect(response.post).toBeDefined();
355:       expect(response.post!.content).toBe('This is a reply');
356:       expect(response.post!.parent_post_id).toBe('parent-post-1');
357:     });
358:     it('should create a reply with tags', async () => {
359:       const result = await createPostToolHandler(
360:         {
361:           content: 'Reply with tags',
362:           tags: ['response', 'feedback'],
363:           parent_post_id: 'parent-post-1',
364:         },
365:         context
366:       );
367:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
368:       expect(response.success).toBe(true);
369:       expect(response.post!.tags).toEqual(['response', 'feedback']);
370:       expect(response.post!.parent_post_id).toBe('parent-post-1');
371:     });
372:     it('should reject reply to non-existent parent post', async () => {
373:       const result = await createPostToolHandler(
374:         {
375:           content: 'Reply to ghost',
376:           parent_post_id: 'non-existent-post',
377:         },
378:         context
379:       );
380:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
381:       expect(response.success).toBe(false);
382:       expect(response.error).toBe('Invalid parent post');
383:       expect(response.details).toContain("Parent post with ID 'non-existent-post' not found");
384:     });
385:     it('should allow nested replies (reply to a reply)', async () => {
386:       // First create a reply
387:       const firstReply = await createPostToolHandler(
388:         {
389:           content: 'First level reply',
390:           parent_post_id: 'parent-post-1',
391:         },
392:         context
393:       );
394:       const firstResponse: CreatePostToolResponse = JSON.parse(firstReply.content[0].text);
395:       expect(firstResponse.success).toBe(true);
396:       const firstReplyId = firstResponse.post!.id;
397:       // Add the reply to mock API so it can be found
398:       mockApiClient.addPost(firstResponse.post!);
399:       // Create a reply to the reply
400:       const nestedReply = await createPostToolHandler(
401:         {
402:           content: 'Nested reply',
403:           parent_post_id: firstReplyId,
404:         },
405:         context
406:       );
407:       const nestedResponse: CreatePostToolResponse = JSON.parse(nestedReply.content[0].text);
408:       expect(nestedResponse.success).toBe(true);
409:       expect(nestedResponse.post!.parent_post_id).toBe(firstReplyId);
410:     });
411:     it('should require login for creating replies', async () => {
412:       // Delete the session
413:       sessionManager.deleteSession('test-session-123');
414:       const result = await createPostToolHandler(
415:         {
416:           content: 'Unauthorized reply',
417:           parent_post_id: 'parent-post-1',
418:         },
419:         context
420:       );
421:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
422:       expect(response.success).toBe(false);
423:       expect(response.error).toBe('Authentication required');
424:     });
425:     it('should handle parent post validation errors gracefully', async () => {
426:       // Make the API fail during parent validation
427:       jest
428:         .spyOn(mockApiClient, 'fetchPosts')
429:         .mockRejectedValueOnce(new Error('Network error during validation'));
430:       const result = await createPostToolHandler(
431:         {
432:           content: 'Reply with network error',
433:           parent_post_id: 'parent-post-1',
434:         },
435:         context
436:       );
437:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
438:       expect(response.success).toBe(false);
439:       expect(response.error).toBe('Failed to validate parent post');
440:       expect(response.details).toContain('Network error during validation');
441:     });
442:     it('should maintain all post properties when creating a reply', async () => {
443:       const content = 'Full featured reply';
444:       const tags = ['important', 'urgent'];
445:       const result = await createPostToolHandler(
446:         {
447:           content,
448:           tags,
449:           parent_post_id: 'parent-post-1',
450:         },
451:         context
452:       );
453:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
454:       expect(response.success).toBe(true);
455:       const post = response.post!;
456:       expect(post.content).toBe(content);
457:       expect(post.tags).toEqual(tags);
458:       expect(post.parent_post_id).toBe('parent-post-1');
459:       expect(post.author_name).toBe('test-agent');
460:       expect(post.team_name).toBe('test-team');
461:       expect(post.id).toBeDefined();
462:       expect(post.timestamp).toBeDefined();
463:     });
464:     it('should create regular posts when parent_post_id is not provided', async () => {
465:       const result = await createPostToolHandler(
466:         {
467:           content: 'Regular post, not a reply',
468:           tags: ['regular'],
469:         },
470:         context
471:       );
472:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
473:       expect(response.success).toBe(true);
474:       expect(response.post!.parent_post_id).toBeUndefined();
475:     });
476:     it('should validate parent_post_id is not empty string', async () => {
477:       const result = await createPostToolHandler(
478:         {
479:           content: 'Reply with empty parent',
480:           parent_post_id: '',
481:         },
482:         context
483:       );
484:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
485:       expect(response.success).toBe(false);
486:       expect(response.error).toBe('Invalid parent post');
487:     });
488:     it('should handle replies from different team posts correctly', async () => {
489:       // Add a post from a different team
490:       mockApiClient.addPost({
491:         id: 'other-team-post',
492:         team_name: 'other-team',
493:         author_name: 'other-author',
494:         content: 'Post from another team',
495:         tags: [],
496:         timestamp: new Date().toISOString(),
497:       });
498:       const result = await createPostToolHandler(
499:         {
500:           content: 'Cross-team reply attempt',
501:           parent_post_id: 'other-team-post',
502:         },
503:         context
504:       );
505:       const response: CreatePostToolResponse = JSON.parse(result.content[0].text);
506:       expect(response.success).toBe(false);
507:       expect(response.error).toBe('Invalid parent post');
508:       expect(response.details).toContain("Parent post with ID 'other-team-post' not found");
509:     });
510:   });
511: });
</file>

<file path="tests/tools/login.test.ts">
  1: // ABOUTME: Tests for the login tool functionality
  2: // ABOUTME: Validates input validation, session creation, and error handling
  3: import { jest } from '@jest/globals';
  4: import { loginToolHandler, LoginToolContext } from '../../src/tools/login';
  5: import { SessionManager } from '../../src/session-manager';
  6: import { LoginToolResponse } from '../../src/types';
  7: describe('Login Tool', () => {
  8:   let sessionManager: SessionManager;
  9:   let context: LoginToolContext;
 10:   let mockGetSessionId: jest.Mock<() => string>;
 11:   beforeEach(() => {
 12:     sessionManager = new SessionManager();
 13:     mockGetSessionId = jest.fn(() => `test-session-${Date.now()}`);
 14:     context = {
 15:       sessionManager,
 16:       getSessionId: mockGetSessionId,
 17:     };
 18:     // Set up environment
 19:     process.env.TEAM_NAME = 'test-team';
 20:   });
 21:   describe('Successful login', () => {
 22:     it('should create a new session for valid agent name', async () => {
 23:       const agentName = 'test-agent';
 24:       const result = await loginToolHandler({ agent_name: agentName }, context);
 25:       expect(result.content).toHaveLength(1);
 26:       expect(result.content[0].type).toBe('text');
 27:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
 28:       expect(response.success).toBe(true);
 29:       expect(response.agent_name).toBe(agentName);
 30:       expect(response.team_name).toBe('test-team');
 31:       expect(response.session_id).toBeDefined();
 32:       // Verify session was created
 33:       const sessionId = response.session_id!;
 34:       const session = sessionManager.getSession(sessionId);
 35:       expect(session).toBeDefined();
 36:       expect(session?.agentName).toBe(agentName);
 37:     });
 38:     it('should trim whitespace from agent name', async () => {
 39:       const agentName = '  test-agent  ';
 40:       const result = await loginToolHandler({ agent_name: agentName }, context);
 41:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
 42:       expect(response.success).toBe(true);
 43:       expect(response.agent_name).toBe('test-agent');
 44:     });
 45:     it('should handle agent names with special characters', async () => {
 46:       const agentName = 'agent-123_特殊字符';
 47:       const result = await loginToolHandler({ agent_name: agentName }, context);
 48:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
 49:       expect(response.success).toBe(true);
 50:       expect(response.agent_name).toBe(agentName);
 51:     });
 52:   });
 53:   describe('Re-login scenarios', () => {
 54:     it('should update existing session on re-login', async () => {
 55:       const sessionId = 'existing-session';
 56:       mockGetSessionId.mockReturnValue(sessionId);
 57:       // First login
 58:       await sessionManager.createSession(sessionId, 'agent-1');
 59:       // Re-login with different agent
 60:       const result = await loginToolHandler({ agent_name: 'agent-2' }, context);
 61:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
 62:       expect(response.success).toBe(true);
 63:       expect(response.agent_name).toBe('agent-2');
 64:       // Verify session was updated
 65:       const session = sessionManager.getSession(sessionId);
 66:       expect(session?.agentName).toBe('agent-2');
 67:     });
 68:     it('should preserve session ID on re-login', async () => {
 69:       const sessionId = 'persistent-session';
 70:       mockGetSessionId.mockReturnValue(sessionId);
 71:       // First login
 72:       const result1 = await loginToolHandler({ agent_name: 'agent-1' }, context);
 73:       const response1: LoginToolResponse = JSON.parse(result1.content[0].text);
 74:       // Re-login
 75:       const result2 = await loginToolHandler({ agent_name: 'agent-2' }, context);
 76:       const response2: LoginToolResponse = JSON.parse(result2.content[0].text);
 77:       expect(response1.session_id).toBe(sessionId);
 78:       expect(response2.session_id).toBe(sessionId);
 79:     });
 80:   });
 81:   describe('Input validation', () => {
 82:     it('should reject empty agent name', async () => {
 83:       const result = await loginToolHandler({ agent_name: '' }, context);
 84:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
 85:       expect(response.success).toBe(false);
 86:       expect(response.error).toBe('Invalid input');
 87:       expect(response.details).toContain('Agent name must not be empty');
 88:     });
 89:     it('should reject whitespace-only agent name', async () => {
 90:       const result = await loginToolHandler({ agent_name: '   ' }, context);
 91:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
 92:       expect(response.success).toBe(false);
 93:       expect(response.error).toBe('Invalid input');
 94:     });
 95:     it('should reject null agent name', async () => {
 96:       const result = await loginToolHandler({ agent_name: null as any }, context);
 97:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
 98:       expect(response.success).toBe(false);
 99:       expect(response.error).toBe('Invalid input');
100:     });
101:     it('should reject undefined agent name', async () => {
102:       const result = await loginToolHandler({ agent_name: undefined as any }, context);
103:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
104:       expect(response.success).toBe(false);
105:       expect(response.error).toBe('Invalid input');
106:     });
107:   });
108:   describe('Error handling', () => {
109:     it('should handle session creation failure', async () => {
110:       // Mock session creation to throw error
111:       jest
112:         .spyOn(sessionManager, 'createSession')
113:         .mockRejectedValueOnce(new Error('Database connection failed'));
114:       const result = await loginToolHandler({ agent_name: 'test-agent' }, context);
115:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
116:       expect(response.success).toBe(false);
117:       expect(response.error).toBe('Failed to create session');
118:       expect(response.details).toBe('Database connection failed');
119:     });
120:     it('should handle unexpected errors', async () => {
121:       // Mock session creation to throw non-Error
122:       jest.spyOn(sessionManager, 'createSession').mockRejectedValueOnce('String error');
123:       const result = await loginToolHandler({ agent_name: 'test-agent' }, context);
124:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
125:       expect(response.success).toBe(false);
126:       expect(response.error).toBe('Failed to create session');
127:       expect(response.details).toBe('Unknown error');
128:     });
129:   });
130:   describe('Session ID generation', () => {
131:     it('should use provided session ID function', async () => {
132:       const customSessionId = 'custom-session-123';
133:       mockGetSessionId.mockReturnValue(customSessionId);
134:       const result = await loginToolHandler({ agent_name: 'test-agent' }, context);
135:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
136:       expect(response.session_id).toBe(customSessionId);
137:       expect(mockGetSessionId).toHaveBeenCalled();
138:     });
139:     it('should call session ID function once per login', async () => {
140:       await loginToolHandler({ agent_name: 'test-agent' }, context);
141:       expect(mockGetSessionId).toHaveBeenCalledTimes(1);
142:     });
143:   });
144:   describe('Response format', () => {
145:     it('should always return MCP-compliant response structure', async () => {
146:       const result = await loginToolHandler({ agent_name: 'test-agent' }, context);
147:       expect(result).toHaveProperty('content');
148:       expect(Array.isArray(result.content)).toBe(true);
149:       expect(result.content[0]).toHaveProperty('type', 'text');
150:       expect(result.content[0]).toHaveProperty('text');
151:       expect(typeof result.content[0].text).toBe('string');
152:       // Verify JSON is valid
153:       expect(() => JSON.parse(result.content[0].text)).not.toThrow();
154:     });
155:     it('should include all required fields in success response', async () => {
156:       const result = await loginToolHandler({ agent_name: 'test-agent' }, context);
157:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
158:       expect(response).toHaveProperty('success', true);
159:       expect(response).toHaveProperty('agent_name');
160:       expect(response).toHaveProperty('team_name');
161:       expect(response).toHaveProperty('session_id');
162:       expect(response).not.toHaveProperty('error');
163:       expect(response).not.toHaveProperty('details');
164:     });
165:     it('should include error fields in failure response', async () => {
166:       const result = await loginToolHandler({ agent_name: '' }, context);
167:       const response: LoginToolResponse = JSON.parse(result.content[0].text);
168:       expect(response).toHaveProperty('success', false);
169:       expect(response).toHaveProperty('error');
170:       expect(response).toHaveProperty('details');
171:       expect(response).not.toHaveProperty('agent_name');
172:       expect(response).not.toHaveProperty('team_name');
173:       expect(response).not.toHaveProperty('session_id');
174:     });
175:   });
176: });
</file>

<file path="tests/api-client.test.ts">
  1: // ABOUTME: Tests for ApiClient functionality
  2: // ABOUTME: Validates API requests, error handling, and mock client behavior
  3: import { jest } from '@jest/globals';
  4: import { ApiClient } from '../src/api-client';
  5: import { MockApiClient } from '../src/mock-api-client';
  6: import { PostData, PostQueryOptions } from '../src/types';
  7: describe('MockApiClient', () => {
  8:   let mockClient: MockApiClient;
  9:   beforeEach(() => {
 10:     mockClient = new MockApiClient();
 11:   });
 12:   describe('fetchPosts', () => {
 13:     it('should fetch posts for a team', async () => {
 14:       const response = await mockClient.fetchPosts('test-team');
 15:       expect(response.posts).toBeDefined();
 16:       expect(response.posts.length).toBeGreaterThan(0);
 17:       expect(response.total).toBeGreaterThan(0);
 18:       expect(response.has_more).toBeDefined();
 19:     });
 20:     it('should filter posts by agent', async () => {
 21:       const options: PostQueryOptions = { agent_filter: 'agent-alice' };
 22:       const response = await mockClient.fetchPosts('test-team', options);
 23:       expect(response.posts.every((post) => post.author_name === 'agent-alice')).toBe(true);
 24:     });
 25:     it('should filter posts by tag', async () => {
 26:       const options: PostQueryOptions = { tag_filter: 'update' };
 27:       const response = await mockClient.fetchPosts('test-team', options);
 28:       expect(response.posts.every((post) => post.tags.includes('update'))).toBe(true);
 29:     });
 30:     it('should filter posts by thread', async () => {
 31:       const options: PostQueryOptions = { thread_id: 'post-seed-2' };
 32:       const response = await mockClient.fetchPosts('test-team', options);
 33:       expect(
 34:         response.posts.some(
 35:           (post) => post.id === 'post-seed-2' || post.parent_post_id === 'post-seed-2'
 36:         )
 37:       ).toBe(true);
 38:     });
 39:     it('should handle pagination', async () => {
 40:       const page1 = await mockClient.fetchPosts('test-team', { limit: 2, offset: 0 });
 41:       const page2 = await mockClient.fetchPosts('test-team', { limit: 2, offset: 2 });
 42:       expect(page1.posts.length).toBeLessThanOrEqual(2);
 43:       expect(page2.posts.length).toBeLessThanOrEqual(2);
 44:       expect(page1.posts[0].id).not.toBe(page2.posts[0]?.id);
 45:     });
 46:     it('should return empty array for non-existent team', async () => {
 47:       const response = await mockClient.fetchPosts('non-existent-team');
 48:       expect(response.posts).toEqual([]);
 49:       expect(response.total).toBe(0);
 50:       expect(response.has_more).toBe(false);
 51:     });
 52:     it('should handle authentication failure', async () => {
 53:       mockClient.setAuthFailure(true);
 54:       await expect(mockClient.fetchPosts('test-team')).rejects.toThrow('Authentication failed');
 55:     });
 56:     it('should handle network failure', async () => {
 57:       mockClient.setNetworkFailure(true);
 58:       await expect(mockClient.fetchPosts('test-team')).rejects.toThrow('Network error');
 59:     });
 60:     it('should handle timeout', async () => {
 61:       mockClient.setTimeout(true);
 62:       await expect(mockClient.fetchPosts('test-team')).rejects.toThrow('Request timeout');
 63:     });
 64:   });
 65:   describe('createPost', () => {
 66:     it('should create a new post', async () => {
 67:       const postData: PostData = {
 68:         author_name: 'agent-test',
 69:         content: 'Test post content',
 70:         tags: ['test', 'example'],
 71:       };
 72:       const response = await mockClient.createPost('test-team', postData);
 73:       expect(response.post).toBeDefined();
 74:       expect(response.post.id).toBeDefined();
 75:       expect(response.post.team_name).toBe('test-team');
 76:       expect(response.post.author_name).toBe(postData.author_name);
 77:       expect(response.post.content).toBe(postData.content);
 78:       expect(response.post.tags).toEqual(postData.tags);
 79:       expect(response.post.timestamp).toBeDefined();
 80:     });
 81:     it('should create a reply post', async () => {
 82:       const postData: PostData = {
 83:         author_name: 'agent-test',
 84:         content: 'Reply content',
 85:         parent_post_id: 'post-seed-1',
 86:       };
 87:       const response = await mockClient.createPost('test-team', postData);
 88:       expect(response.post.parent_post_id).toBe('post-seed-1');
 89:     });
 90:     it('should increment post count', async () => {
 91:       const initialCount = mockClient.getPostCount();
 92:       await mockClient.createPost('test-team', {
 93:         author_name: 'agent-test',
 94:         content: 'New post',
 95:       });
 96:       expect(mockClient.getPostCount()).toBe(initialCount + 1);
 97:     });
 98:     it('should handle authentication failure', async () => {
 99:       mockClient.setAuthFailure(true);
100:       await expect(
101:         mockClient.createPost('test-team', {
102:           author_name: 'agent-test',
103:           content: 'Test',
104:         })
105:       ).rejects.toThrow('Authentication failed');
106:     });
107:     it('should handle network failure', async () => {
108:       mockClient.setNetworkFailure(true);
109:       await expect(
110:         mockClient.createPost('test-team', {
111:           author_name: 'agent-test',
112:           content: 'Test',
113:         })
114:       ).rejects.toThrow('Network error');
115:     });
116:   });
117:   describe('test helpers', () => {
118:     it('should simulate response delay', async () => {
119:       mockClient.setResponseDelay(100);
120:       const start = Date.now();
121:       await mockClient.fetchPosts('test-team');
122:       const duration = Date.now() - start;
123:       expect(duration).toBeGreaterThanOrEqual(100);
124:     });
125:     it('should clear all posts', async () => {
126:       mockClient.clearPosts();
127:       const response = await mockClient.fetchPosts('test-team');
128:       expect(response.posts).toEqual([]);
129:       expect(mockClient.getPostCount()).toBe(0);
130:     });
131:     it('should add custom posts', async () => {
132:       mockClient.clearPosts();
133:       mockClient.addPost({
134:         id: 'custom-1',
135:         team_name: 'test-team',
136:         author_name: 'custom-agent',
137:         content: 'Custom content',
138:         tags: ['custom'],
139:         timestamp: new Date().toISOString(),
140:       });
141:       const response = await mockClient.fetchPosts('test-team');
142:       expect(response.posts.length).toBe(1);
143:       expect(response.posts[0].id).toBe('custom-1');
144:     });
145:   });
146: });
147: describe('ApiClient', () => {
148:   let apiClient: ApiClient;
149:   beforeEach(() => {
150:     // Set up test environment variables
151:     process.env.SOCIAL_API_BASE_URL = 'https://api.test.com';
152:     process.env.SOCIAL_API_KEY = 'test-key';
153:     process.env.API_TIMEOUT = '5000';
154:     apiClient = new ApiClient();
155:   });
156:   describe('constructor', () => {
157:     it('should use provided configuration', () => {
158:       const customClient = new ApiClient('https://custom.api.com', 'custom-key', 10000);
159:       // We can't directly test private properties, but we can verify through behavior
160:       expect(customClient).toBeDefined();
161:     });
162:     it('should remove trailing slash from base URL', () => {
163:       const customClient = new ApiClient('https://api.test.com/', 'test-key', 5000);
164:       expect(customClient).toBeDefined();
165:     });
166:   });
167:   describe('URL construction', () => {
168:     it('should build correct URL for fetchPosts', () => {
169:       // This is tested indirectly through the mock client
170:       // In a real implementation, you might mock the fetch function
171:       expect(true).toBe(true);
172:     });
173:     it('should encode team names properly', () => {
174:       // This is tested indirectly through the mock client
175:       expect(true).toBe(true);
176:     });
177:     it('should build query parameters correctly', () => {
178:       // This is tested indirectly through the mock client
179:       expect(true).toBe(true);
180:     });
181:   });
182: });
</file>

<file path="tests/config.test.ts">
 1: // ABOUTME: Tests for configuration management
 2: // ABOUTME: Validates environment variable loading and config validation
 3: import { jest } from '@jest/globals';
 4: import { validateConfig, getConfig } from '../src/config';
 5: describe('Config', () => {
 6:   const originalEnv = process.env;
 7:   beforeEach(() => {
 8:     process.env = { ...originalEnv };
 9:   });
10:   afterAll(() => {
11:     process.env = originalEnv;
12:   });
13:   describe('validateConfig', () => {
14:     it('should validate a complete configuration', () => {
15:       process.env.SOCIAL_API_BASE_URL = 'https://api.example.com';
16:       process.env.SOCIAL_API_KEY = 'test-key';
17:       process.env.TEAM_NAME = 'test-team';
18:       process.env.PORT = '3000';
19:       expect(() => validateConfig()).not.toThrow();
20:     });
21:     it('should throw error for missing SOCIAL_API_BASE_URL', () => {
22:       delete process.env.SOCIAL_API_BASE_URL;
23:       process.env.SOCIAL_API_KEY = 'test-key';
24:       process.env.TEAM_NAME = 'test-team';
25:       expect(() => validateConfig()).toThrow(
26:         'Missing required environment variable: SOCIAL_API_BASE_URL'
27:       );
28:     });
29:     it('should throw error for missing SOCIAL_API_KEY', () => {
30:       process.env.SOCIAL_API_BASE_URL = 'https://api.example.com';
31:       delete process.env.SOCIAL_API_KEY;
32:       process.env.TEAM_NAME = 'test-team';
33:       expect(() => validateConfig()).toThrow(
34:         'Missing required environment variable: SOCIAL_API_KEY'
35:       );
36:     });
37:     it('should throw error for missing TEAM_NAME', () => {
38:       process.env.SOCIAL_API_BASE_URL = 'https://api.example.com';
39:       process.env.SOCIAL_API_KEY = 'test-key';
40:       delete process.env.TEAM_NAME;
41:       expect(() => validateConfig()).toThrow('Missing required environment variable: TEAM_NAME');
42:     });
43:     it('should throw error for invalid PORT', () => {
44:       process.env.SOCIAL_API_BASE_URL = 'https://api.example.com';
45:       process.env.SOCIAL_API_KEY = 'test-key';
46:       process.env.TEAM_NAME = 'test-team';
47:       process.env.PORT = '70000';
48:       expect(() => validateConfig()).toThrow('PORT must be a valid port number');
49:     });
50:     it('should use default PORT if not specified', () => {
51:       process.env.SOCIAL_API_BASE_URL = 'https://api.example.com';
52:       process.env.SOCIAL_API_KEY = 'test-key';
53:       process.env.TEAM_NAME = 'test-team';
54:       delete process.env.PORT;
55:       const config = getConfig();
56:       expect(config.port).toBe(3000);
57:     });
58:     it('should use default LOG_LEVEL if not specified', () => {
59:       process.env.SOCIAL_API_BASE_URL = 'https://api.example.com';
60:       process.env.SOCIAL_API_KEY = 'test-key';
61:       process.env.TEAM_NAME = 'test-team';
62:       delete process.env.LOG_LEVEL;
63:       const config = getConfig();
64:       expect(config.logLevel).toBe('info');
65:     });
66:   });
67: });
</file>

<file path="tests/session-manager.test.ts">
  1: // ABOUTME: Tests for SessionManager functionality
  2: // ABOUTME: Validates session creation, retrieval, deletion, and cleanup
  3: import { jest } from '@jest/globals';
  4: import { SessionManager } from '../src/session-manager';
  5: import { Session } from '../src/types';
  6: describe('SessionManager', () => {
  7:   let sessionManager: SessionManager;
  8:   beforeEach(() => {
  9:     sessionManager = new SessionManager();
 10:   });
 11:   describe('createSession', () => {
 12:     it('should create a new session', async () => {
 13:       const sessionId = 'test-session-123';
 14:       const agentName = 'test-agent';
 15:       const session = await sessionManager.createSession(sessionId, agentName);
 16:       expect(session).toBeDefined();
 17:       expect(session.sessionId).toBe(sessionId);
 18:       expect(session.agentName).toBe(agentName);
 19:       expect(session.loginTimestamp).toBeInstanceOf(Date);
 20:     });
 21:     it('should update an existing session', async () => {
 22:       const sessionId = 'test-session-123';
 23:       const firstAgent = 'agent-1';
 24:       const secondAgent = 'agent-2';
 25:       const firstSession = await sessionManager.createSession(sessionId, firstAgent);
 26:       const firstTimestamp = firstSession.loginTimestamp;
 27:       // Wait a bit to ensure timestamp difference
 28:       await new Promise((resolve) => setTimeout(resolve, 10));
 29:       const secondSession = await sessionManager.createSession(sessionId, secondAgent);
 30:       expect(secondSession.agentName).toBe(secondAgent);
 31:       expect(secondSession.loginTimestamp.getTime()).toBeGreaterThan(firstTimestamp.getTime());
 32:     });
 33:   });
 34:   describe('getSession', () => {
 35:     it('should retrieve an existing session', async () => {
 36:       const sessionId = 'test-session-123';
 37:       const agentName = 'test-agent';
 38:       await sessionManager.createSession(sessionId, agentName);
 39:       const retrieved = sessionManager.getSession(sessionId);
 40:       expect(retrieved).toBeDefined();
 41:       expect(retrieved?.sessionId).toBe(sessionId);
 42:       expect(retrieved?.agentName).toBe(agentName);
 43:     });
 44:     it('should return undefined for non-existent session', () => {
 45:       const retrieved = sessionManager.getSession('non-existent');
 46:       expect(retrieved).toBeUndefined();
 47:     });
 48:   });
 49:   describe('deleteSession', () => {
 50:     it('should delete an existing session', async () => {
 51:       const sessionId = 'test-session-123';
 52:       await sessionManager.createSession(sessionId, 'test-agent');
 53:       const deleted = sessionManager.deleteSession(sessionId);
 54:       expect(deleted).toBe(true);
 55:       const retrieved = sessionManager.getSession(sessionId);
 56:       expect(retrieved).toBeUndefined();
 57:     });
 58:     it('should return false when deleting non-existent session', () => {
 59:       const deleted = sessionManager.deleteSession('non-existent');
 60:       expect(deleted).toBe(false);
 61:     });
 62:   });
 63:   describe('hasValidSession', () => {
 64:     it('should return true for existing session', async () => {
 65:       const sessionId = 'test-session-123';
 66:       await sessionManager.createSession(sessionId, 'test-agent');
 67:       expect(sessionManager.hasValidSession(sessionId)).toBe(true);
 68:     });
 69:     it('should return false for non-existent session', () => {
 70:       expect(sessionManager.hasValidSession('non-existent')).toBe(false);
 71:     });
 72:   });
 73:   describe('getAllSessions', () => {
 74:     it('should return all active sessions', async () => {
 75:       await sessionManager.createSession('session-1', 'agent-1');
 76:       await sessionManager.createSession('session-2', 'agent-2');
 77:       await sessionManager.createSession('session-3', 'agent-3');
 78:       const allSessions = sessionManager.getAllSessions();
 79:       expect(allSessions).toHaveLength(3);
 80:       const sessionIds = allSessions.map((s) => s.sessionId);
 81:       expect(sessionIds).toContain('session-1');
 82:       expect(sessionIds).toContain('session-2');
 83:       expect(sessionIds).toContain('session-3');
 84:     });
 85:     it('should return empty array when no sessions exist', () => {
 86:       const allSessions = sessionManager.getAllSessions();
 87:       expect(allSessions).toEqual([]);
 88:     });
 89:   });
 90:   describe('clearAllSessions', () => {
 91:     it('should remove all sessions', async () => {
 92:       await sessionManager.createSession('session-1', 'agent-1');
 93:       await sessionManager.createSession('session-2', 'agent-2');
 94:       sessionManager.clearAllSessions();
 95:       expect(sessionManager.getSessionCount()).toBe(0);
 96:       expect(sessionManager.getAllSessions()).toEqual([]);
 97:     });
 98:   });
 99:   describe('getSessionCount', () => {
100:     it('should return correct session count', async () => {
101:       expect(sessionManager.getSessionCount()).toBe(0);
102:       await sessionManager.createSession('session-1', 'agent-1');
103:       expect(sessionManager.getSessionCount()).toBe(1);
104:       await sessionManager.createSession('session-2', 'agent-2');
105:       expect(sessionManager.getSessionCount()).toBe(2);
106:       sessionManager.deleteSession('session-1');
107:       expect(sessionManager.getSessionCount()).toBe(1);
108:     });
109:   });
110:   describe('cleanupOldSessions', () => {
111:     it('should remove sessions older than specified age', async () => {
112:       // Create sessions with different timestamps
113:       const oldSession = await sessionManager.createSession('old-session', 'old-agent');
114:       // Manually set old timestamp
115:       oldSession.loginTimestamp = new Date(Date.now() - 3600000); // 1 hour ago
116:       // Create recent sessions
117:       await sessionManager.createSession('recent-1', 'agent-1');
118:       await sessionManager.createSession('recent-2', 'agent-2');
119:       // Cleanup sessions older than 30 minutes
120:       const removed = sessionManager.cleanupOldSessions(1800000);
121:       expect(removed).toBe(1);
122:       expect(sessionManager.getSessionCount()).toBe(2);
123:       expect(sessionManager.hasValidSession('old-session')).toBe(false);
124:       expect(sessionManager.hasValidSession('recent-1')).toBe(true);
125:       expect(sessionManager.hasValidSession('recent-2')).toBe(true);
126:     });
127:     it('should not remove any sessions if all are recent', async () => {
128:       await sessionManager.createSession('session-1', 'agent-1');
129:       await sessionManager.createSession('session-2', 'agent-2');
130:       const removed = sessionManager.cleanupOldSessions(3600000); // 1 hour
131:       expect(removed).toBe(0);
132:       expect(sessionManager.getSessionCount()).toBe(2);
133:     });
134:   });
135:   describe('edge cases', () => {
136:     it('should handle empty string sessionId', async () => {
137:       const session = await sessionManager.createSession('', 'agent');
138:       expect(session.sessionId).toBe('');
139:       expect(sessionManager.hasValidSession('')).toBe(true);
140:     });
141:     it('should handle empty string agentName', async () => {
142:       const session = await sessionManager.createSession('session-123', '');
143:       expect(session.agentName).toBe('');
144:     });
145:     it('should handle special characters in sessionId and agentName', async () => {
146:       const sessionId = 'session-!@#$%^&*()_+-=[]{}|;:,.<>?';
147:       const agentName = 'agent-特殊字符-🎯';
148:       const session = await sessionManager.createSession(sessionId, agentName);
149:       expect(session.sessionId).toBe(sessionId);
150:       expect(session.agentName).toBe(agentName);
151:       const retrieved = sessionManager.getSession(sessionId);
152:       expect(retrieved?.agentName).toBe(agentName);
153:     });
154:     it('should handle concurrent session operations', async () => {
155:       const promises = [];
156:       // Create 100 sessions concurrently
157:       for (let i = 0; i < 100; i++) {
158:         promises.push(sessionManager.createSession(`session-${i}`, `agent-${i}`));
159:       }
160:       await Promise.all(promises);
161:       expect(sessionManager.getSessionCount()).toBe(100);
162:     });
163:   });
164:   describe('memory cleanup', () => {
165:     it('should release memory when sessions are deleted', async () => {
166:       // Create and delete many sessions
167:       for (let i = 0; i < 1000; i++) {
168:         await sessionManager.createSession(`session-${i}`, `agent-${i}`);
169:       }
170:       expect(sessionManager.getSessionCount()).toBe(1000);
171:       // Delete all sessions
172:       for (let i = 0; i < 1000; i++) {
173:         sessionManager.deleteSession(`session-${i}`);
174:       }
175:       expect(sessionManager.getSessionCount()).toBe(0);
176:       expect(sessionManager.getAllSessions()).toEqual([]);
177:     });
178:   });
179: });
</file>

<file path=".gitignore">
 1: # Dependencies
 2: node_modules/
 3:
 4: # Build output
 5: dist/
 6:
 7: # Environment files
 8: .env
 9: .env.local
10: .env.development
11: .env.production
12:
13: # IDE files
14: .vscode/
15: .idea/
16: *.swp
17: *.swo
18:
19: # OS files
20: .DS_Store
21: Thumbs.db
22:
23: # Logs
24: logs/
25: *.log
26: npm-debug.log*
27: yarn-debug.log*
28: yarn-error.log*
29:
30: # Testing
31: coverage/
32: .nyc_output/
33:
34: # Temporary files
35: tmp/
36: temp/
</file>

<file path="jest.config.js">
 1: /** @type {import('jest').Config} */
 2: export default {
 3:   preset: 'ts-jest/presets/default-esm',
 4:   testEnvironment: 'node',
 5:   extensionsToTreatAsEsm: ['.ts'],
 6:   moduleNameMapper: {
 7:     '^(\\.{1,2}/.*)\\.js$': '$1',
 8:   },
 9:   transform: {
10:     '^.+\\.tsx?$': [
11:       'ts-jest',
12:       {
13:         useESM: true,
14:         tsconfig: {
15:           module: 'ESNext',
16:           moduleResolution: 'Node',
17:         },
18:       },
19:     ],
20:   },
21:   testMatch: ['**/tests/**/*.test.ts'],
22:   collectCoverageFrom: ['src/**/*.ts', '!src/**/*.d.ts'],
23:   coverageDirectory: 'coverage',
24:   coverageReporters: ['text', 'lcov', 'html'],
25: };
</file>

<file path="tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "target": "ES2022",
 4:     "module": "NodeNext",
 5:     "moduleResolution": "NodeNext",
 6:     "lib": ["ES2022"],
 7:     "outDir": "./dist",
 8:     "rootDir": "./src",
 9:     "strict": true,
10:     "esModuleInterop": true,
11:     "skipLibCheck": true,
12:     "forceConsistentCasingInFileNames": true,
13:     "resolveJsonModule": true,
14:     "declaration": true,
15:     "declarationMap": true,
16:     "sourceMap": true,
17:     "allowSyntheticDefaultImports": true,
18:     "isolatedModules": true
19:   },
20:   "include": ["src/**/*"],
21:   "exclude": ["node_modules", "dist", "tests"]
22: }
</file>

<file path="src/tools/create-post.ts">
  1: // ABOUTME: Create post tool implementation for creating new social media posts
  2: // ABOUTME: Requires session validation and integrates with the API client
  3: import { SessionManager } from '../session-manager.js';
  4: import { IApiClient } from '../api-client.js';
  5: import { CreatePostToolResponse } from '../types.js';
  6: import { config } from '../config.js';
  7: import { z } from 'zod';
  8: import { validateCreatePostInput } from '../validation.js';
  9: export const createPostToolSchema = {
 10:   description: 'Create a new post or reply within the team',
 11:   inputSchema: {
 12:     content: z.string().min(1).describe('The content of the post'),
 13:     tags: z.array(z.string()).optional().describe('Optional tags for the post'),
 14:     parent_post_id: z.string().optional().describe('ID of the post to reply to (optional)'),
 15:   },
 16: };
 17: export interface CreatePostToolContext {
 18:   sessionManager: SessionManager;
 19:   apiClient: IApiClient;
 20:   getSessionId: () => string;
 21: }
 22: export async function createPostToolHandler(
 23:   input: any,
 24:   context: CreatePostToolContext
 25: ): Promise<{ content: Array<{ type: 'text'; text: string }> }> {
 26:   try {
 27:     // Validate input
 28:     const validation = validateCreatePostInput(input);
 29:     if (!validation.isValid) {
 30:       const response: CreatePostToolResponse = {
 31:         success: false,
 32:         error: 'Invalid input',
 33:         details: validation.errors.map((e) => `${e.field}: ${e.message}`).join(', '),
 34:       };
 35:       return {
 36:         content: [
 37:           {
 38:             type: 'text',
 39:             text: JSON.stringify(response),
 40:           },
 41:         ],
 42:       };
 43:     }
 44:     const { content, tags, parent_post_id } = validation.data;
 45:     // Note: Empty tags will be filtered out later during processing
 46:     // Get session ID and check if user is logged in
 47:     const sessionId = context.getSessionId();
 48:     const session = context.sessionManager.getSession(sessionId);
 49:     if (!session) {
 50:       const response: CreatePostToolResponse = {
 51:         success: false,
 52:         error: 'Authentication required',
 53:         details: 'You must be logged in to create posts',
 54:       };
 55:       return {
 56:         content: [
 57:           {
 58:             type: 'text',
 59:             text: JSON.stringify(response),
 60:           },
 61:         ],
 62:       };
 63:     }
 64:     // Validate parent post exists if parent_post_id is provided
 65:     if (parent_post_id !== undefined && parent_post_id !== null) {
 66:       try {
 67:         // Use the API client to check if the parent post exists
 68:         const parentPostsResponse = await context.apiClient.fetchPosts(config.teamName, {
 69:           limit: 1,
 70:           offset: 0,
 71:         });
 72:         // Check if the parent post exists in the team's posts
 73:         const allPosts = parentPostsResponse.posts;
 74:         const parentExists = allPosts.some((post) => post.id === parent_post_id);
 75:         if (!parentExists) {
 76:           // Try to fetch more posts to be thorough
 77:           const extendedResponse = await context.apiClient.fetchPosts(config.teamName, {
 78:             limit: 100,
 79:             offset: 0,
 80:           });
 81:           const parentExistsExtended = extendedResponse.posts.some(
 82:             (post) => post.id === parent_post_id
 83:           );
 84:           if (!parentExistsExtended) {
 85:             const response: CreatePostToolResponse = {
 86:               success: false,
 87:               error: 'Invalid parent post',
 88:               details: `Parent post with ID '${parent_post_id}' not found`,
 89:             };
 90:             return {
 91:               content: [
 92:                 {
 93:                   type: 'text',
 94:                   text: JSON.stringify(response),
 95:                 },
 96:               ],
 97:             };
 98:           }
 99:         }
100:       } catch (error) {
101:         const response: CreatePostToolResponse = {
102:           success: false,
103:           error: 'Failed to validate parent post',
104:           details: error instanceof Error ? error.message : 'Unknown error',
105:         };
106:         return {
107:           content: [
108:             {
109:               type: 'text',
110:               text: JSON.stringify(response),
111:             },
112:           ],
113:         };
114:       }
115:     }
116:     // Prepare post data
117:     const postData = {
118:       author_name: session.agentName,
119:       content: content,
120:       tags: tags?.length > 0 ? tags : undefined,
121:       parent_post_id: parent_post_id,
122:     };
123:     // Call API to create post
124:     const apiResponse = await context.apiClient.createPost(config.teamName, postData);
125:     // Return successful response
126:     const response: CreatePostToolResponse = {
127:       success: true,
128:       post: apiResponse.post,
129:     };
130:     return {
131:       content: [
132:         {
133:           type: 'text',
134:           text: JSON.stringify(response),
135:         },
136:       ],
137:     };
138:   } catch (error) {
139:     // Handle API errors
140:     const response: CreatePostToolResponse = {
141:       success: false,
142:       error: 'Failed to create post',
143:       details: error instanceof Error ? error.message : 'Unknown error',
144:     };
145:     return {
146:       content: [
147:         {
148:           type: 'text',
149:           text: JSON.stringify(response),
150:         },
151:       ],
152:     };
153:   }
154: }
</file>

<file path="tests/tools/read-posts.test.ts">
  1: // ABOUTME: Tests for the read posts tool functionality
  2: // ABOUTME: Validates post retrieval, pagination, and error handling
  3: import { jest } from '@jest/globals';
  4: import { readPostsToolHandler, ReadPostsToolContext } from '../../src/tools/read-posts';
  5: import { MockApiClient } from '../../src/mock-api-client';
  6: import { ReadPostsToolResponse, Post } from '../../src/types';
  7: describe('Read Posts Tool', () => {
  8:   let mockApiClient: MockApiClient;
  9:   let context: ReadPostsToolContext;
 10:   beforeEach(() => {
 11:     // Set up environment
 12:     process.env.TEAM_NAME = 'test-team';
 13:     mockApiClient = new MockApiClient();
 14:     context = {
 15:       apiClient: mockApiClient,
 16:     };
 17:   });
 18:   describe('Successful post retrieval', () => {
 19:     it('should fetch posts with default parameters', async () => {
 20:       const result = await readPostsToolHandler({}, context);
 21:       expect(result.content).toHaveLength(1);
 22:       expect(result.content[0].type).toBe('text');
 23:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
 24:       expect(response.posts).toBeDefined();
 25:       expect(Array.isArray(response.posts)).toBe(true);
 26:       expect(response.posts?.length).toBeGreaterThan(0);
 27:       expect(response.limit).toBe(10);
 28:       expect(response.offset).toBe(0);
 29:       expect(response.error).toBeUndefined();
 30:     });
 31:     it('should fetch posts with custom limit', async () => {
 32:       const result = await readPostsToolHandler({ limit: 5 }, context);
 33:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
 34:       expect(response.posts?.length).toBeLessThanOrEqual(5);
 35:       expect(response.limit).toBe(5);
 36:       expect(response.offset).toBe(0);
 37:     });
 38:     it('should fetch posts with custom offset', async () => {
 39:       const result = await readPostsToolHandler({ offset: 2 }, context);
 40:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
 41:       expect(response.posts).toBeDefined();
 42:       expect(response.limit).toBe(10);
 43:       expect(response.offset).toBe(2);
 44:     });
 45:     it('should fetch posts with both limit and offset', async () => {
 46:       const result = await readPostsToolHandler({ limit: 3, offset: 1 }, context);
 47:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
 48:       expect(response.posts).toBeDefined();
 49:       expect(response.limit).toBe(3);
 50:       expect(response.offset).toBe(1);
 51:     });
 52:     it('should return posts with correct structure', async () => {
 53:       const result = await readPostsToolHandler({}, context);
 54:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
 55:       const posts = response.posts!;
 56:       expect(posts.length).toBeGreaterThan(0);
 57:       const post = posts[0];
 58:       expect(post).toHaveProperty('id');
 59:       expect(post).toHaveProperty('team_name');
 60:       expect(post).toHaveProperty('author_name');
 61:       expect(post).toHaveProperty('content');
 62:       expect(post).toHaveProperty('tags');
 63:       expect(post).toHaveProperty('timestamp');
 64:       // parent_post_id is optional
 65:     });
 66:   });
 67:   describe('Pagination', () => {
 68:     it('should handle pagination correctly', async () => {
 69:       // Get first page
 70:       const page1Result = await readPostsToolHandler({ limit: 2, offset: 0 }, context);
 71:       const page1Response: ReadPostsToolResponse = JSON.parse(page1Result.content[0].text);
 72:       // Get second page
 73:       const page2Result = await readPostsToolHandler({ limit: 2, offset: 2 }, context);
 74:       const page2Response: ReadPostsToolResponse = JSON.parse(page2Result.content[0].text);
 75:       // Verify different posts
 76:       expect(page1Response.posts![0].id).not.toBe(page2Response.posts![0]?.id);
 77:     });
 78:     it('should handle large offset values', async () => {
 79:       const result = await readPostsToolHandler({ offset: 1000 }, context);
 80:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
 81:       expect(response.posts).toBeDefined();
 82:       expect(response.posts?.length).toBe(0); // No posts at such high offset
 83:       expect(response.error).toBeUndefined();
 84:     });
 85:     it('should handle limit edge cases', async () => {
 86:       // Minimum limit
 87:       const minResult = await readPostsToolHandler({ limit: 1 }, context);
 88:       const minResponse: ReadPostsToolResponse = JSON.parse(minResult.content[0].text);
 89:       expect(minResponse.posts?.length).toBe(1);
 90:       // Maximum reasonable limit
 91:       const maxResult = await readPostsToolHandler({ limit: 100 }, context);
 92:       const maxResponse: ReadPostsToolResponse = JSON.parse(maxResult.content[0].text);
 93:       expect(maxResponse.posts).toBeDefined();
 94:       expect(maxResponse.limit).toBe(100);
 95:     });
 96:   });
 97:   describe('Empty results', () => {
 98:     it('should handle empty post list gracefully', async () => {
 99:       // Clear all posts
100:       mockApiClient.clearPosts();
101:       const result = await readPostsToolHandler({}, context);
102:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
103:       expect(response.posts).toEqual([]);
104:       expect(response.error).toBeUndefined();
105:       expect(response.limit).toBe(10);
106:       expect(response.offset).toBe(0);
107:     });
108:     it('should handle team with no posts gracefully', async () => {
109:       // Clear all posts and add one for a different team
110:       mockApiClient.clearPosts();
111:       mockApiClient.addPost({
112:         id: 'other-team-post',
113:         team_name: 'other-team',
114:         author_name: 'other-agent',
115:         content: 'Post from another team',
116:         tags: [],
117:         timestamp: new Date().toISOString(),
118:       });
119:       const result = await readPostsToolHandler({}, context);
120:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
121:       expect(response.posts).toEqual([]);
122:       expect(response.error).toBeUndefined();
123:     });
124:   });
125:   describe('Error handling', () => {
126:     it('should handle API authentication failure', async () => {
127:       mockApiClient.setAuthFailure(true);
128:       const result = await readPostsToolHandler({}, context);
129:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
130:       expect(response.posts).toEqual([]);
131:       expect(response.error).toContain('Authentication failed');
132:       expect(response.limit).toBe(10);
133:       expect(response.offset).toBe(0);
134:     });
135:     it('should handle network errors', async () => {
136:       mockApiClient.setNetworkFailure(true);
137:       const result = await readPostsToolHandler({}, context);
138:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
139:       expect(response.posts).toEqual([]);
140:       expect(response.error).toContain('Network error');
141:     });
142:     it('should handle API timeout', async () => {
143:       mockApiClient.setTimeout(true);
144:       const result = await readPostsToolHandler({}, context);
145:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
146:       expect(response.posts).toEqual([]);
147:       expect(response.error).toContain('Request timeout');
148:     });
149:     it('should handle unexpected errors', async () => {
150:       // Mock fetchPosts to throw unexpected error
151:       jest.spyOn(mockApiClient, 'fetchPosts').mockRejectedValueOnce(new Error('Unexpected error'));
152:       const result = await readPostsToolHandler({}, context);
153:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
154:       expect(response.posts).toEqual([]);
155:       expect(response.error).toBe('Unexpected error');
156:     });
157:   });
158:   describe('Response format', () => {
159:     it('should always return MCP-compliant response structure', async () => {
160:       const result = await readPostsToolHandler({}, context);
161:       expect(result).toHaveProperty('content');
162:       expect(Array.isArray(result.content)).toBe(true);
163:       expect(result.content[0]).toHaveProperty('type', 'text');
164:       expect(result.content[0]).toHaveProperty('text');
165:       expect(typeof result.content[0].text).toBe('string');
166:       // Verify JSON is valid
167:       expect(() => JSON.parse(result.content[0].text)).not.toThrow();
168:     });
169:     it('should include all fields in successful response', async () => {
170:       const result = await readPostsToolHandler({ limit: 5, offset: 2 }, context);
171:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
172:       expect(response).toHaveProperty('posts');
173:       expect(response).toHaveProperty('limit', 5);
174:       expect(response).toHaveProperty('offset', 2);
175:       expect(response).not.toHaveProperty('error');
176:     });
177:     it('should include error field in failure response', async () => {
178:       mockApiClient.setAuthFailure(true);
179:       const result = await readPostsToolHandler({}, context);
180:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
181:       expect(response).toHaveProperty('posts', []);
182:       expect(response).toHaveProperty('error');
183:       expect(response).toHaveProperty('limit');
184:       expect(response).toHaveProperty('offset');
185:     });
186:   });
187:   describe('Integration with team configuration', () => {
188:     it('should use team name from configuration', async () => {
189:       const fetchPostsSpy = jest.spyOn(mockApiClient, 'fetchPosts');
190:       await readPostsToolHandler({}, context);
191:       expect(fetchPostsSpy).toHaveBeenCalledWith('test-team', expect.any(Object));
192:     });
193:     it('should pass correct options to API client', async () => {
194:       const fetchPostsSpy = jest.spyOn(mockApiClient, 'fetchPosts');
195:       await readPostsToolHandler({ limit: 15, offset: 5 }, context);
196:       expect(fetchPostsSpy).toHaveBeenCalledWith('test-team', {
197:         limit: 15,
198:         offset: 5,
199:         agent_filter: undefined,
200:         tag_filter: undefined,
201:         thread_id: undefined,
202:       });
203:     });
204:   });
205:   describe('Filtering functionality', () => {
206:     it('should filter posts by agent name', async () => {
207:       const result = await readPostsToolHandler({ agent_filter: 'agent-alice' }, context);
208:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
209:       expect(response.posts).toBeDefined();
210:       expect(response.posts!.length).toBeGreaterThan(0);
211:       expect(response.posts!.every((post) => post.author_name === 'agent-alice')).toBe(true);
212:     });
213:     it('should filter posts by tag', async () => {
214:       const result = await readPostsToolHandler({ tag_filter: 'update' }, context);
215:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
216:       expect(response.posts).toBeDefined();
217:       expect(response.posts!.length).toBeGreaterThan(0);
218:       expect(response.posts!.every((post) => post.tags.includes('update'))).toBe(true);
219:     });
220:     it('should filter posts by thread ID', async () => {
221:       const result = await readPostsToolHandler({ thread_id: 'post-seed-2' }, context);
222:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
223:       expect(response.posts).toBeDefined();
224:       expect(response.posts!.length).toBeGreaterThan(0);
225:       // Should include the thread parent and its replies
226:       const postIds = response.posts!.map((p) => p.id);
227:       expect(postIds).toContain('post-seed-2');
228:       const hasReply = response.posts!.some((p) => p.parent_post_id === 'post-seed-2');
229:       expect(hasReply).toBe(true);
230:     });
231:     it('should support combined filters', async () => {
232:       const result = await readPostsToolHandler(
233:         {
234:           agent_filter: 'agent-alice',
235:           tag_filter: 'update',
236:           limit: 5,
237:         },
238:         context
239:       );
240:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
241:       expect(response.posts).toBeDefined();
242:       expect(
243:         response.posts!.every(
244:           (post) => post.author_name === 'agent-alice' && post.tags.includes('update')
245:         )
246:       ).toBe(true);
247:       expect(response.limit).toBe(5);
248:     });
249:     it('should handle filters with no matching posts', async () => {
250:       const result = await readPostsToolHandler({ agent_filter: 'non-existent-agent' }, context);
251:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
252:       expect(response.posts).toEqual([]);
253:       expect(response.error).toBeUndefined();
254:     });
255:     it('should trim filter values', async () => {
256:       const fetchPostsSpy = jest.spyOn(mockApiClient, 'fetchPosts');
257:       await readPostsToolHandler(
258:         {
259:           agent_filter: '  agent-alice  ',
260:           tag_filter: ' update ',
261:           thread_id: ' post-seed-2 ',
262:         },
263:         context
264:       );
265:       expect(fetchPostsSpy).toHaveBeenCalledWith('test-team', {
266:         limit: 10,
267:         offset: 0,
268:         agent_filter: 'agent-alice',
269:         tag_filter: 'update',
270:         thread_id: 'post-seed-2',
271:       });
272:     });
273:   });
274:   describe('Parameter validation', () => {
275:     it('should reject empty agent_filter', async () => {
276:       const result = await readPostsToolHandler({ agent_filter: '' }, context);
277:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
278:       expect(response.posts).toEqual([]);
279:       expect(response.error).toContain('agent_filter cannot be empty');
280:     });
281:     it('should reject empty tag_filter', async () => {
282:       const result = await readPostsToolHandler({ tag_filter: '   ' }, context);
283:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
284:       expect(response.posts).toEqual([]);
285:       expect(response.error).toContain('tag_filter cannot be empty');
286:     });
287:     it('should reject empty thread_id', async () => {
288:       const result = await readPostsToolHandler({ thread_id: '' }, context);
289:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
290:       expect(response.posts).toEqual([]);
291:       expect(response.error).toContain('thread_id cannot be empty');
292:     });
293:     it('should allow undefined filters', async () => {
294:       const result = await readPostsToolHandler(
295:         {
296:           agent_filter: undefined,
297:           tag_filter: undefined,
298:           thread_id: undefined,
299:         },
300:         context
301:       );
302:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
303:       expect(response.posts).toBeDefined();
304:       expect(response.error).toBeUndefined();
305:     });
306:   });
307:   describe('Complex filtering scenarios', () => {
308:     it('should handle pagination with filters', async () => {
309:       // Get first page of alice's posts
310:       const page1 = await readPostsToolHandler(
311:         {
312:           agent_filter: 'agent-alice',
313:           limit: 1,
314:           offset: 0,
315:         },
316:         context
317:       );
318:       // Get second page
319:       const page2 = await readPostsToolHandler(
320:         {
321:           agent_filter: 'agent-alice',
322:           limit: 1,
323:           offset: 1,
324:         },
325:         context
326:       );
327:       const response1: ReadPostsToolResponse = JSON.parse(page1.content[0].text);
328:       const response2: ReadPostsToolResponse = JSON.parse(page2.content[0].text);
329:       // Should get different posts
330:       if (response1.posts!.length > 0 && response2.posts!.length > 0) {
331:         expect(response1.posts![0].id).not.toBe(response2.posts![0].id);
332:       }
333:     });
334:     it('should handle multiple tags correctly', async () => {
335:       // Add a post with multiple tags
336:       mockApiClient.addPost({
337:         id: 'multi-tag-post',
338:         team_name: 'test-team',
339:         author_name: 'agent-test',
340:         content: 'Post with multiple tags',
341:         tags: ['development', 'update', 'feature'],
342:         timestamp: new Date().toISOString(),
343:       });
344:       // Should find the post when filtering by any of its tags
345:       const result = await readPostsToolHandler({ tag_filter: 'feature' }, context);
346:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
347:       const multiTagPost = response.posts!.find((p) => p.id === 'multi-tag-post');
348:       expect(multiTagPost).toBeDefined();
349:     });
350:     it('should handle thread filtering with nested replies', async () => {
351:       // Add nested thread structure
352:       const rootId = 'thread-root';
353:       const reply1Id = 'thread-reply-1';
354:       mockApiClient.addPost({
355:         id: rootId,
356:         team_name: 'test-team',
357:         author_name: 'agent-root',
358:         content: 'Root post',
359:         tags: ['discussion'],
360:         timestamp: new Date(Date.now() - 3000).toISOString(),
361:       });
362:       mockApiClient.addPost({
363:         id: reply1Id,
364:         team_name: 'test-team',
365:         author_name: 'agent-reply',
366:         content: 'Reply to root',
367:         tags: ['reply'],
368:         timestamp: new Date(Date.now() - 2000).toISOString(),
369:         parent_post_id: rootId,
370:       });
371:       mockApiClient.addPost({
372:         id: 'thread-reply-2',
373:         team_name: 'test-team',
374:         author_name: 'agent-nested',
375:         content: 'Reply to reply',
376:         tags: ['nested'],
377:         timestamp: new Date(Date.now() - 1000).toISOString(),
378:         parent_post_id: reply1Id,
379:       });
380:       // Filter by root thread ID should get root and direct replies
381:       const result = await readPostsToolHandler({ thread_id: rootId }, context);
382:       const response: ReadPostsToolResponse = JSON.parse(result.content[0].text);
383:       const threadPosts = response.posts!.filter(
384:         (p) => p.id === rootId || p.parent_post_id === rootId
385:       );
386:       expect(threadPosts.length).toBeGreaterThanOrEqual(2);
387:     });
388:   });
389: });
</file>

<file path=".eslintrc.json">
 1: {
 2:   "env": {
 3:     "es2021": true,
 4:     "node": true
 5:   },
 6:   "extends": [
 7:     "eslint:recommended",
 8:     "plugin:@typescript-eslint/recommended",
 9:     "plugin:import/errors",
10:     "plugin:import/warnings",
11:     "plugin:import/typescript"
12:   ],
13:   "parser": "@typescript-eslint/parser",
14:   "parserOptions": {
15:     "ecmaVersion": "latest",
16:     "sourceType": "module",
17:     "project": "./tsconfig.json"
18:   },
19:   "plugins": ["@typescript-eslint", "import"],
20:   "rules": {
21:     "@typescript-eslint/explicit-function-return-type": "off",
22:     "@typescript-eslint/explicit-module-boundary-types": "off",
23:     "@typescript-eslint/no-explicit-any": "warn",
24:     "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
25:     "import/order": [
26:       "error",
27:       {
28:         "groups": ["builtin", "external", "internal", "parent", "sibling", "index"],
29:         "newlines-between": "never"
30:       }
31:     ],
32:     "import/no-unresolved": "error",
33:     "import/extensions": [
34:       "error",
35:       "ignorePackages",
36:       {
37:         "ts": "never",
38:         "tsx": "never"
39:       }
40:     ]
41:   },
42:   "settings": {
43:     "import/resolver": {
44:       "typescript": {
45:         "alwaysTryTypes": true,
46:         "project": "./tsconfig.json"
47:       }
48:     }
49:   },
50:   "ignorePatterns": ["dist/", "node_modules/", "*.js", "tests/", "**/*.test.ts"],
51:   "globals": {
52:     "jest": true,
53:     "describe": true,
54:     "it": true,
55:     "expect": true,
56:     "beforeEach": true,
57:     "afterEach": true,
58:     "beforeAll": true,
59:     "afterAll": true
60:   }
61: }
</file>

<file path="eslint.config.js">
 1: import js from '@eslint/js';
 2: import typescript from '@typescript-eslint/eslint-plugin';
 3: import tsParser from '@typescript-eslint/parser';
 4: export default [
 5:   js.configs.recommended,
 6:   {
 7:     files: ['src/**/*.ts'],
 8:     languageOptions: {
 9:       parser: tsParser,
10:       parserOptions: {
11:         ecmaVersion: 2022,
12:         sourceType: 'module',
13:       },
14:       globals: {
15:         console: 'readonly',
16:         process: 'readonly',
17:         global: 'readonly',
18:         setInterval: 'readonly',
19:         clearInterval: 'readonly',
20:         setTimeout: 'readonly',
21:         clearTimeout: 'readonly',
22:         URLSearchParams: 'readonly',
23:         AbortController: 'readonly',
24:       },
25:     },
26:     plugins: {
27:       '@typescript-eslint': typescript,
28:     },
29:     rules: {
30:       ...typescript.configs.recommended.rules,
31:       '@typescript-eslint/explicit-function-return-type': 'off',
32:       '@typescript-eslint/no-explicit-any': 'warn',
33:       '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
34:     },
35:   },
36: ];
</file>

<file path="package.json">
 1: {
 2:   "name": "mcp-agent-social",
 3:   "version": "1.0.0",
 4:   "description": "MCP server for agent social media platform",
 5:   "main": "dist/index.js",
 6:   "scripts": {
 7:     "build": "tsc",
 8:     "start": "node dist/index.js",
 9:     "dev": "tsx watch src/index.ts",
10:     "test": "NODE_OPTIONS=\"--experimental-vm-modules\" jest",
11:     "test:watch": "NODE_OPTIONS=\"--experimental-vm-modules\" jest --watch",
12:     "lint": "eslint src/**/*.ts",
13:     "typecheck": "tsc --noEmit"
14:   },
15:   "keywords": [
16:     "mcp",
17:     "model-context-protocol",
18:     "social-media",
19:     "agents"
20:   ],
21:   "author": "",
22:   "license": "MIT",
23:   "type": "module",
24:   "dependencies": {
25:     "@modelcontextprotocol/sdk": "^1.12.1",
26:     "@types/node-fetch": "^2.6.12",
27:     "dotenv": "^16.5.0",
28:     "node-fetch": "^3.3.2",
29:     "zod": "^3.25.49"
30:   },
31:   "devDependencies": {
32:     "@eslint/js": "^9.28.0",
33:     "@types/jest": "^29.5.14",
34:     "@types/node": "^22.15.29",
35:     "@typescript-eslint/eslint-plugin": "^8.33.1",
36:     "@typescript-eslint/parser": "^8.33.1",
37:     "eslint": "^9.28.0",
38:     "jest": "^29.7.0",
39:     "ts-jest": "^29.3.4",
40:     "tsx": "^4.19.4",
41:     "typescript": "^5.8.3"
42:   }
43: }
</file>

<file path="src/tools/login.ts">
  1: // ABOUTME: Login tool implementation for agent authentication
  2: // ABOUTME: Handles session creation and validation for agents
  3: import { SessionManager } from '../session-manager.js';
  4: import { LoginToolResponse } from '../types.js';
  5: import { config } from '../config.js';
  6: import { logger } from '../logger.js';
  7: import { withMetrics } from '../metrics.js';
  8: import { z } from 'zod';
  9: import { validateLoginInput } from '../validation.js';
 10: export const loginToolSchema = {
 11:   description: 'Authenticate and set agent identity for the session',
 12:   inputSchema: {
 13:     agent_name: z.string().min(1).describe('The name of the agent logging in'),
 14:   },
 15: };
 16: export interface LoginToolContext {
 17:   sessionManager: SessionManager;
 18:   getSessionId: () => string;
 19: }
 20: export async function loginToolHandler(
 21:   input: any,
 22:   context: LoginToolContext
 23: ): Promise<{ content: Array<{ type: 'text'; text: string }> }> {
 24:   const startTime = Date.now();
 25:   const sessionId = context.getSessionId();
 26:   logger.toolStart('login', input, { sessionId });
 27:   return withMetrics('login', async () => {
 28:     try {
 29:       // Validate input
 30:       const validation = validateLoginInput(input);
 31:       if (!validation.isValid) {
 32:         const response: LoginToolResponse = {
 33:           success: false,
 34:           error: 'Invalid input',
 35:           details: validation.errors.map((e) => `${e.field}: ${e.message}`).join(', '),
 36:         };
 37:         logger.warn('Login failed - invalid input', { sessionId, errors: validation.errors });
 38:         return {
 39:           content: [
 40:             {
 41:               type: 'text',
 42:               text: JSON.stringify(response),
 43:             },
 44:           ],
 45:         };
 46:       }
 47:       const { agent_name } = validation.data;
 48:       // Check if session already exists (re-login scenario)
 49:       const existingSession = context.sessionManager.getSession(sessionId);
 50:       if (existingSession) {
 51:         // Update existing session
 52:         await context.sessionManager.createSession(sessionId, agent_name.trim());
 53:         const response: LoginToolResponse = {
 54:           success: true,
 55:           agent_name: agent_name.trim(),
 56:           team_name: config.teamName,
 57:           session_id: sessionId,
 58:         };
 59:         logger.info('Re-login successful', {
 60:           sessionId,
 61:           agentName: agent_name.trim(),
 62:           previousAgent: existingSession.agentName,
 63:         });
 64:         logger.toolSuccess('login', Date.now() - startTime, {
 65:           sessionId,
 66:           agentName: agent_name.trim(),
 67:         });
 68:         return {
 69:           content: [
 70:             {
 71:               type: 'text',
 72:               text: JSON.stringify(response),
 73:             },
 74:           ],
 75:         };
 76:       }
 77:       // Create new session
 78:       const session = await context.sessionManager.createSession(sessionId, agent_name.trim());
 79:       logger.sessionCreated(sessionId, agent_name.trim());
 80:       const response: LoginToolResponse = {
 81:         success: true,
 82:         agent_name: session.agentName,
 83:         team_name: config.teamName,
 84:         session_id: session.sessionId,
 85:       };
 86:       logger.toolSuccess('login', Date.now() - startTime, {
 87:         sessionId,
 88:         agentName: session.agentName,
 89:       });
 90:       return {
 91:         content: [
 92:           {
 93:             type: 'text',
 94:             text: JSON.stringify(response),
 95:           },
 96:         ],
 97:       };
 98:     } catch (error) {
 99:       const response: LoginToolResponse = {
100:         success: false,
101:         error: 'Failed to create session',
102:         details: error instanceof Error ? error.message : 'Unknown error',
103:       };
104:       logger.toolError('login', error as Error, Date.now() - startTime, { sessionId });
105:       return {
106:         content: [
107:           {
108:             type: 'text',
109:             text: JSON.stringify(response),
110:           },
111:         ],
112:       };
113:     }
114:   });
115: }
</file>

<file path="src/tools/read-posts.ts">
 1: // ABOUTME: Read posts tool implementation for retrieving social media posts
 2: // ABOUTME: Handles basic pagination and error handling for post retrieval
 3: import { IApiClient } from '../api-client.js';
 4: import { ReadPostsToolResponse } from '../types.js';
 5: import { config } from '../config.js';
 6: import { z } from 'zod';
 7: import { validateReadPostsInput } from '../validation.js';
 8: export const readPostsToolSchema = {
 9:   description: "Retrieve posts from the team's social feed with optional filtering",
10:   inputSchema: {
11:     limit: z.number().min(1).max(100).default(10).describe('Maximum number of posts to retrieve'),
12:     offset: z.number().min(0).default(0).describe('Number of posts to skip'),
13:     agent_filter: z.string().optional().describe('Filter posts by author name'),
14:     tag_filter: z.string().optional().describe('Filter posts by tag'),
15:     thread_id: z.string().optional().describe('Get posts in a specific thread'),
16:   },
17: };
18: export interface ReadPostsToolContext {
19:   apiClient: IApiClient;
20: }
21: export async function readPostsToolHandler(
22:   input: any,
23:   context: ReadPostsToolContext
24: ): Promise<{ content: Array<{ type: 'text'; text: string }> }> {
25:   try {
26:     // Validate input
27:     const validation = validateReadPostsInput(input);
28:     if (!validation.isValid) {
29:       const response: ReadPostsToolResponse = {
30:         posts: [],
31:         limit: 10,
32:         offset: 0,
33:         error:
34:           'Invalid input: ' + validation.errors.map((e) => `${e.field}: ${e.message}`).join(', '),
35:       };
36:       return {
37:         content: [
38:           {
39:             type: 'text',
40:             text: JSON.stringify(response),
41:           },
42:         ],
43:       };
44:     }
45:     const {
46:       limit: actualLimit,
47:       offset: actualOffset,
48:       agent_filter,
49:       tag_filter,
50:       thread_id,
51:     } = validation.data;
52:     // Fetch posts from the API with filters
53:     const response = await context.apiClient.fetchPosts(config.teamName, {
54:       limit: actualLimit,
55:       offset: actualOffset,
56:       agent_filter: agent_filter?.trim(),
57:       tag_filter: tag_filter?.trim(),
58:       thread_id: thread_id?.trim(),
59:     });
60:     // Format successful response
61:     const toolResponse: ReadPostsToolResponse = {
62:       posts: response.posts,
63:       limit: actualLimit,
64:       offset: actualOffset,
65:     };
66:     return {
67:       content: [
68:         {
69:           type: 'text',
70:           text: JSON.stringify(toolResponse),
71:         },
72:       ],
73:     };
74:   } catch (error) {
75:     // Handle API errors
76:     const errorResponse: ReadPostsToolResponse = {
77:       posts: [],
78:       error: error instanceof Error ? error.message : 'Failed to fetch posts',
79:       limit: 10,
80:       offset: 0,
81:     };
82:     return {
83:       content: [
84:         {
85:           type: 'text',
86:           text: JSON.stringify(errorResponse),
87:         },
88:       ],
89:     };
90:   }
91: }
</file>

<file path="src/config.ts">
 1: // ABOUTME: Configuration management for the MCP server
 2: // ABOUTME: Loads and validates environment variables
 3: import { config as loadDotenv } from 'dotenv';
 4: import { ServerConfig } from './types.js';
 5: loadDotenv();
 6: function getEnvVar(name: string, defaultValue?: string): string {
 7:   const value = process.env[name];
 8:   if (!value && !defaultValue) {
 9:     throw new Error(`Missing required environment variable: ${name}`);
10:   }
11:   return value || defaultValue!;
12: }
13: export function getConfig(): ServerConfig {
14:   return {
15:     socialApiBaseUrl: getEnvVar('SOCIAL_API_BASE_URL'),
16:     socialApiKey: getEnvVar('SOCIAL_API_KEY'),
17:     teamName: getEnvVar('TEAM_NAME'),
18:     port: parseInt(getEnvVar('PORT', '3000'), 10),
19:     logLevel: getEnvVar('LOG_LEVEL', 'info'),
20:     apiTimeout: parseInt(getEnvVar('API_TIMEOUT', '30000'), 10), // 30 seconds default
21:   };
22: }
23: export const config: ServerConfig = getConfig();
24: export function validateConfig(): void {
25:   const errors: string[] = [];
26:   try {
27:     const conf = getConfig();
28:     if (!conf.socialApiBaseUrl) {
29:       errors.push('SOCIAL_API_BASE_URL is required');
30:     }
31:     if (!conf.socialApiKey) {
32:       errors.push('SOCIAL_API_KEY is required');
33:     }
34:     if (!conf.teamName) {
35:       errors.push('TEAM_NAME is required');
36:     }
37:     if (isNaN(conf.port) || conf.port < 1 || conf.port > 65535) {
38:       errors.push('PORT must be a valid port number (1-65535)');
39:     }
40:   } catch (error) {
41:     errors.push(error instanceof Error ? error.message : 'Unknown error');
42:   }
43:   if (errors.length > 0) {
44:     throw new Error(`Configuration validation failed:\n${errors.join('\n')}`);
45:   }
46: }
</file>

<file path="tests/server.test.ts">
  1: // ABOUTME: Tests for the MCP server initialization and basic functionality
  2: // ABOUTME: Validates server setup, tool registration, and error handling
  3: import { McpServer } from '@modelcontextprotocol/sdk/server/mcp';
  4: import { z } from 'zod';
  5: describe('MCP Agent Social Server', () => {
  6:   let server: McpServer;
  7:   beforeEach(async () => {
  8:     // Set up required environment variables
  9:     process.env.SOCIAL_API_BASE_URL = 'https://api.example.com';
 10:     process.env.SOCIAL_API_KEY = 'test-key';
 11:     process.env.TEAM_NAME = 'test-team';
 12:     // Create server
 13:     server = new McpServer({
 14:       name: 'mcp-agent-social',
 15:       version: '1.0.0',
 16:     });
 17:     // Register tools
 18:     server.registerTool(
 19:       'login',
 20:       {
 21:         description: 'Authenticate and set agent identity for the session',
 22:         inputSchema: {
 23:           agent_name: z.string().describe('The name of the agent logging in'),
 24:         },
 25:       },
 26:       async ({ agent_name }) => {
 27:         // Simulate the login functionality
 28:         const sessionId = `test-session-${Date.now()}`;
 29:         return {
 30:           content: [
 31:             {
 32:               type: 'text',
 33:               text: JSON.stringify({
 34:                 success: true,
 35:                 agent_name: agent_name,
 36:                 team_name: 'test-team',
 37:                 session_id: sessionId,
 38:               }),
 39:             },
 40:           ],
 41:         };
 42:       }
 43:     );
 44:     server.registerTool(
 45:       'read_posts',
 46:       {
 47:         description: "Retrieve posts from the team's social feed",
 48:         inputSchema: {
 49:           limit: z.number().optional().default(10).describe('Maximum number of posts to retrieve'),
 50:           offset: z.number().optional().default(0).describe('Number of posts to skip'),
 51:         },
 52:       },
 53:       async ({ limit, offset }) => {
 54:         return {
 55:           content: [
 56:             {
 57:               type: 'text',
 58:               text: JSON.stringify({
 59:                 posts: [],
 60:                 limit,
 61:                 offset,
 62:               }),
 63:             },
 64:           ],
 65:         };
 66:       }
 67:     );
 68:     server.registerTool(
 69:       'create_post',
 70:       {
 71:         description: 'Create a new post or reply within the team',
 72:         inputSchema: {
 73:           content: z.string().describe('The content of the post'),
 74:           tags: z.array(z.string()).optional().describe('Optional tags for the post'),
 75:         },
 76:       },
 77:       async ({ content, tags }) => {
 78:         return {
 79:           content: [
 80:             {
 81:               type: 'text',
 82:               text: JSON.stringify({
 83:                 success: false,
 84:                 error: 'Not implemented yet',
 85:                 content,
 86:                 tags,
 87:               }),
 88:             },
 89:           ],
 90:         };
 91:       }
 92:     );
 93:   });
 94:   afterEach(async () => {
 95:     if (server) {
 96:       await server.close();
 97:     }
 98:   });
 99:   describe('Server Creation', () => {
100:     it('should create server with correct configuration', () => {
101:       expect(server).toBeDefined();
102:       expect(server).toBeInstanceOf(McpServer);
103:     });
104:   });
105:   describe('Tool Registration', () => {
106:     it('should successfully register login tool', () => {
107:       // Tool registration happens in beforeEach
108:       // If no error is thrown, registration was successful
109:       expect(true).toBe(true);
110:     });
111:     it('should successfully register read_posts tool', () => {
112:       // Tool registration happens in beforeEach
113:       // If no error is thrown, registration was successful
114:       expect(true).toBe(true);
115:     });
116:     it('should successfully register create_post tool', () => {
117:       // Tool registration happens in beforeEach
118:       // If no error is thrown, registration was successful
119:       expect(true).toBe(true);
120:     });
121:   });
122:   describe('Tool Handler Functions', () => {
123:     it('login handler should return expected format', async () => {
124:       const loginHandler = async ({ agent_name }: { agent_name: string }) => {
125:         return {
126:           content: [
127:             {
128:               type: 'text',
129:               text: JSON.stringify({
130:                 success: true,
131:                 agent_name,
132:                 team_name: 'test-team',
133:                 session_id: `test-session-${Date.now()}`,
134:               }),
135:             },
136:           ],
137:         };
138:       };
139:       const result = await loginHandler({ agent_name: 'test-agent' });
140:       expect(result.content).toHaveLength(1);
141:       expect(result.content[0].type).toBe('text');
142:       const parsed = JSON.parse(result.content[0].text);
143:       expect(parsed).toMatchObject({
144:         success: true,
145:         agent_name: 'test-agent',
146:         team_name: 'test-team',
147:       });
148:       expect(parsed.session_id).toBeDefined();
149:     });
150:     it('read_posts handler should return expected format', async () => {
151:       const readPostsHandler = async ({ limit, offset }: { limit: number; offset: number }) => {
152:         return {
153:           content: [
154:             {
155:               type: 'text',
156:               text: JSON.stringify({
157:                 posts: [],
158:                 error: 'Not implemented yet',
159:                 limit,
160:                 offset,
161:               }),
162:             },
163:           ],
164:         };
165:       };
166:       const result = await readPostsHandler({ limit: 5, offset: 0 });
167:       expect(result.content).toHaveLength(1);
168:       expect(result.content[0].type).toBe('text');
169:       const parsed = JSON.parse(result.content[0].text);
170:       expect(parsed).toMatchObject({
171:         posts: [],
172:         limit: 5,
173:         offset: 0,
174:       });
175:     });
176:     it('create_post handler should return expected format', async () => {
177:       const createPostHandler = async ({ content, tags }: { content: string; tags?: string[] }) => {
178:         return {
179:           content: [
180:             {
181:               type: 'text',
182:               text: JSON.stringify({
183:                 success: false,
184:                 error: 'Not implemented yet',
185:                 content,
186:                 tags,
187:               }),
188:             },
189:           ],
190:         };
191:       };
192:       const result = await createPostHandler({
193:         content: 'Test post',
194:         tags: ['test', 'example'],
195:       });
196:       expect(result.content).toHaveLength(1);
197:       expect(result.content[0].type).toBe('text');
198:       const parsed = JSON.parse(result.content[0].text);
199:       expect(parsed).toMatchObject({
200:         success: false,
201:         error: 'Not implemented yet',
202:         content: 'Test post',
203:         tags: ['test', 'example'],
204:       });
205:     });
206:   });
207: });
</file>

<file path=".env.example">
  1: # MCP Agent Social Media Server Configuration Template
  2: # Copy this file to .env and update the values
  3:
  4: # ============================================================================
  5: # REQUIRED CONFIGURATION
  6: # ============================================================================
  7:
  8: # Team namespace for posts (required)
  9: # This scopes all posts to your team
 10: TEAM_NAME=my-team
 11:
 12: # External API configuration (required)
 13: # Base URL for the social media API
 14: SOCIAL_API_BASE_URL=https://api.social.example.com
 15:
 16: # API authentication key (required)
 17: # Keep this secret! Never commit to version control
 18: SOCIAL_API_KEY=your-secret-api-key-here
 19:
 20: # ============================================================================
 21: # OPTIONAL CONFIGURATION
 22: # ============================================================================
 23:
 24: # Logging Configuration
 25: # Options: ERROR, WARN, INFO, DEBUG
 26: LOG_LEVEL=INFO
 27:
 28: # Node.js Environment
 29: # Options: development, production, test
 30: NODE_ENV=development
 31:
 32: # Server Configuration (if running as HTTP server)
 33: PORT=3000
 34:
 35: # ============================================================================
 36: # API CLIENT SETTINGS
 37: # ============================================================================
 38:
 39: # Request timeout in milliseconds
 40: API_TIMEOUT=30000
 41:
 42: # Maximum number of retries for failed requests
 43: MAX_RETRIES=3
 44:
 45: # Connection pool settings
 46: API_MAX_SOCKETS=100
 47: API_KEEP_ALIVE=true
 48: API_KEEP_ALIVE_TIMEOUT=60000
 49:
 50: # ============================================================================
 51: # SESSION MANAGEMENT
 52: # ============================================================================
 53:
 54: # Session cleanup interval in milliseconds (1 hour)
 55: SESSION_CLEANUP_INTERVAL=3600000
 56:
 57: # Maximum session age in milliseconds (24 hours)
 58: SESSION_MAX_AGE=86400000
 59:
 60: # ============================================================================
 61: # PERFORMANCE TUNING
 62: # ============================================================================
 63:
 64: # Enable caching
 65: ENABLE_CACHE=false
 66:
 67: # Cache time-to-live in milliseconds (5 minutes)
 68: CACHE_TTL=300000
 69:
 70: # Maximum number of cached items
 71: CACHE_MAX_SIZE=1000
 72:
 73: # Memory monitoring
 74: ENABLE_MEMORY_MONITORING=false
 75: MEMORY_WARNING_THRESHOLD=1024
 76:
 77: # ============================================================================
 78: # DEVELOPMENT SETTINGS
 79: # ============================================================================
 80:
 81: # Enable debug output (development only)
 82: # DEBUG=mcp:*
 83:
 84: # Disable SSL verification (development only - NEVER use in production)
 85: # NODE_TLS_REJECT_UNAUTHORIZED=0
 86:
 87: # ============================================================================
 88: # PRODUCTION SETTINGS
 89: # ============================================================================
 90:
 91: # Node.js memory settings (production)
 92: # NODE_OPTIONS=--max-old-space-size=4096
 93:
 94: # Enable production optimizations
 95: # NODE_ENV=production
 96: # LOG_LEVEL=WARN
 97:
 98: # ============================================================================
 99: # MONITORING & OBSERVABILITY
100: # ============================================================================
101:
102: # Metrics collection
103: ENABLE_METRICS=true
104:
105: # Health check settings
106: HEALTH_CHECK_INTERVAL=30000
107: HEALTH_CHECK_TIMEOUT=5000
108:
109: # ============================================================================
110: # DOCKER COMPOSE SETTINGS
111: # ============================================================================
112:
113: # Redis configuration (if using distributed sessions)
114: # REDIS_URL=redis://localhost:6379
115: # REDIS_PASSWORD=your-redis-password
116:
117: # Prometheus settings (if using monitoring)
118: # PROMETHEUS_PORT=9090
119:
120: # Grafana settings (if using dashboards)
121: # GRAFANA_PASSWORD=your-grafana-password
122:
123: # ============================================================================
124: # EXAMPLE CONFIGURATIONS
125: # ============================================================================
126:
127: # Example for development environment:
128: # TEAM_NAME=dev-team
129: # SOCIAL_API_BASE_URL=http://localhost:8080
130: # SOCIAL_API_KEY=dev-key-123456
131: # LOG_LEVEL=DEBUG
132: # NODE_ENV=development
133:
134: # Example for staging environment:
135: # TEAM_NAME=staging-team
136: # SOCIAL_API_BASE_URL=https://api-staging.social.example.com
137: # SOCIAL_API_KEY=staging-key-abcdef
138: # LOG_LEVEL=INFO
139: # NODE_ENV=production
140:
141: # Example for production environment:
142: # TEAM_NAME=production-team
143: # SOCIAL_API_BASE_URL=https://api.social.example.com
144: # SOCIAL_API_KEY=prod-key-secret
145: # LOG_LEVEL=WARN
146: # NODE_ENV=production
147: # API_TIMEOUT=60000
148: # MAX_RETRIES=5
</file>

<file path="src/types.ts">
 1: // ABOUTME: Type definitions for the MCP Agent Social Media Server
 2: // ABOUTME: Contains interfaces and types used throughout the application
 3: export interface ServerConfig {
 4:   socialApiBaseUrl: string;
 5:   socialApiKey: string;
 6:   teamName: string;
 7:   port: number;
 8:   logLevel: string;
 9:   apiTimeout: number;
10: }
11: export interface MCPError {
12:   code: string;
13:   message: string;
14:   data?: unknown;
15: }
16: export interface Session {
17:   sessionId: string;
18:   agentName: string;
19:   loginTimestamp: Date;
20: }
21: export interface Post {
22:   id: string;
23:   team_name: string;
24:   author_name: string;
25:   content: string;
26:   tags: string[];
27:   timestamp: string;
28:   parent_post_id?: string;
29: }
30: export interface PostData {
31:   author_name: string;
32:   content: string;
33:   tags?: string[];
34:   parent_post_id?: string;
35: }
36: export interface PostResponse {
37:   post: Post;
38: }
39: export interface PostsResponse {
40:   posts: Post[];
41:   total: number;
42:   has_more: boolean;
43: }
44: export interface PostQueryOptions {
45:   limit?: number;
46:   offset?: number;
47:   agent_filter?: string;
48:   tag_filter?: string;
49:   thread_id?: string;
50: }
51: export interface ApiError {
52:   status: number;
53:   message: string;
54:   code?: string;
55: }
56: export interface LoginToolResponse {
57:   success: boolean;
58:   agent_name?: string;
59:   team_name?: string;
60:   session_id?: string;
61:   error?: string;
62:   details?: string;
63: }
64: export interface ReadPostsToolResponse {
65:   posts?: Post[];
66:   error?: string;
67:   limit?: number;
68:   offset?: number;
69: }
70: export interface CreatePostToolResponse {
71:   success?: boolean;
72:   post?: Post;
73:   error?: string;
74:   details?: string;
75: }
</file>

<file path="src/index.ts">
 1: // ABOUTME: Main entry point for the MCP Agent Social Media Server
 2: // ABOUTME: Initializes and starts the MCP server with social media tools
 3: import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 4: import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
 5: import { config, validateConfig } from './config.js';
 6: import { SessionManager } from './session-manager.js';
 7: import { ApiClient } from './api-client.js';
 8: import { MockApiClient } from './mock-api-client.js';
 9: import { loginToolSchema, loginToolHandler } from './tools/login.js';
10: import { readPostsToolSchema, readPostsToolHandler } from './tools/read-posts.js';
11: import { createPostToolSchema, createPostToolHandler } from './tools/create-post.js';
12: const server = new McpServer({
13:   name: 'mcp-agent-social',
14:   version: '1.0.0',
15: });
16: // Initialize session manager
17: const sessionManager = new SessionManager();
18: // Initialize API client (use mock for development if specified)
19: // Will be used by tools in later implementations
20: const apiClient = process.env.USE_MOCK_API === 'true' ? new MockApiClient() : new ApiClient();
21: // Store cleanup interval globally for shutdown
22: let cleanupInterval: ReturnType<typeof setInterval> | null = null;
23: // Register the login tool
24: server.registerTool('login', loginToolSchema, async (args, _mcpContext) => {
25:   // Create context for the login tool
26:   const toolContext = {
27:     sessionManager,
28:     getSessionId: () => `session-${Date.now()}-${Math.random().toString(36).substring(7)}`,
29:   };
30:   return loginToolHandler(args, toolContext);
31: });
32: // Register the read_posts tool
33: server.registerTool('read_posts', readPostsToolSchema, async (args, _mcpContext) => {
34:   // Create context for the read posts tool
35:   const toolContext = {
36:     apiClient,
37:   };
38:   return readPostsToolHandler(args, toolContext);
39: });
40: // Register the create_post tool
41: server.registerTool('create_post', createPostToolSchema, async (args, _mcpContext) => {
42:   // Create context for the create post tool
43:   const toolContext = {
44:     sessionManager,
45:     apiClient,
46:     getSessionId: () => `session-${Date.now()}-${Math.random().toString(36).substring(7)}`,
47:   };
48:   return createPostToolHandler(args, toolContext);
49: });
50: async function main() {
51:   try {
52:     validateConfig();
53:     console.error(`Starting MCP server for team: ${config.teamName}`);
54:     console.error(`API endpoint: ${config.socialApiBaseUrl}`);
55:     const transport = new StdioServerTransport();
56:     await server.connect(transport);
57:     console.error('MCP Agent Social Server running...');
58:     // Set up graceful shutdown
59:     process.on('SIGINT', () => shutdown('SIGINT'));
60:     process.on('SIGTERM', () => shutdown('SIGTERM'));
61:     // Set up periodic session cleanup (every 30 minutes)
62:     cleanupInterval = setInterval(() => {
63:       const removed = sessionManager.cleanupOldSessions(3600000); // 1 hour
64:       if (removed > 0) {
65:         console.error(`Cleaned up ${removed} old sessions`);
66:       }
67:     }, 1800000); // 30 minutes
68:   } catch (error) {
69:     console.error('Failed to start server:', error);
70:     process.exit(1);
71:   }
72: }
73: async function shutdown(signal: string) {
74:   console.error(`\nReceived ${signal}, shutting down gracefully...`);
75:   // Clear cleanup interval
76:   if (cleanupInterval) {
77:     clearInterval(cleanupInterval);
78:   }
79:   // Clean up sessions
80:   const sessionCount = sessionManager.getSessionCount();
81:   if (sessionCount > 0) {
82:     console.error(`Cleaning up ${sessionCount} active sessions...`);
83:     sessionManager.clearAllSessions();
84:   }
85:   // Close server
86:   await server.close();
87:   process.exit(0);
88: }
89: main().catch((error) => {
90:   console.error('Unhandled error:', error);
91:   process.exit(1);
92: });
</file>

<file path="prompt_plan.md">
  1: # MCP Agent Social Media Server - Development Blueprint
  2:
  3: ## Project Overview
  4:
  5: Building an MCP server that provides social media functionality for AI agents within team namespaces, integrating with an external API as the source of truth.
  6:
  7: ## High-Level Architecture
  8:
  9: 1. **MCP Server Framework** - Handle MCP protocol communication
 10: 2. **Session Management** - Track logged-in agents per connection
 11: 3. **External API Client** - Interface with team-namespaced social API
 12: 4. **Tool Implementations** - login, read_posts, create_post
 13: 5. **Error Handling & Validation** - Robust input validation and error responses
 14:
 15: ## Development Strategy
 16:
 17: - Start with minimal viable implementation
 18: - Add one feature at a time with full testing
 19: - Maintain working state after each step
 20: - Progressive complexity increase
 21:
 22: ---
 23:
 24: ## Step-by-Step Implementation Plan
 25:
 26: ### Phase 1: Foundation & Setup
 27:
 28: #### Step 1: Project Structure & Basic MCP Server
 29:
 30: - Set up TypeScript project with MCP SDK
 31: - Create basic server that can start and handle connections
 32: - Implement basic error handling
 33: - Add environment variable configuration
 34:
 35: #### Step 2: Session Management System
 36:
 37: - Implement in-memory session storage
 38: - Create session utilities (create, get, delete)
 39: - Add session-based error handling
 40:
 41: #### Step 3: External API Client Foundation
 42:
 43: - Create HTTP client for external API
 44: - Implement authentication headers
 45: - Add basic error handling for API calls
 46: - Create mock API responses for testing
 47:
 48: ### Phase 2: Core Tools Implementation
 49:
 50: #### Step 4: Login Tool Implementation
 51:
 52: - Implement login tool with session creation
 53: - Add input validation
 54: - Connect to session management
 55: - Full test coverage
 56:
 57: #### Step 5: Read Posts Tool - Basic Implementation
 58:
 59: - Implement read_posts without filtering
 60: - Connect to external API client
 61: - Handle pagination basics
 62: - Add response formatting
 63:
 64: #### Step 6: Read Posts Tool - Advanced Features
 65:
 66: - Add filtering capabilities (agent, tag, thread)
 67: - Implement proper pagination
 68: - Enhanced error handling
 69: - Comprehensive testing
 70:
 71: #### Step 7: Create Post Tool Implementation
 72:
 73: - Implement create_post for new posts
 74: - Add session validation (must be logged in)
 75: - Connect to external API
 76: - Input validation and testing
 77:
 78: #### Step 8: Reply Functionality
 79:
 80: - Extend create_post to handle replies
 81: - Add parent_post_id validation
 82: - Thread relationship handling
 83: - Integration testing
 84:
 85: ### Phase 3: Integration & Polish
 86:
 87: #### Step 9: End-to-End Integration
 88:
 89: - Wire all components together
 90: - Integration testing across all tools
 91: - Error flow testing
 92: - Performance validation
 93:
 94: #### Step 10: Documentation & Deployment Prep
 95:
 96: - Add comprehensive documentation
 97: - Create deployment configuration
 98: - Final testing and validation
 99:
100: ---
101:
102: ## Detailed Step Breakdown
103:
104: ### Step 1: Project Structure & Basic MCP Server
105:
106: **Objective**: Create a working MCP server that can start and handle basic connections.
107:
108: **Deliverables**:
109:
110: - TypeScript project with proper structure
111: - Basic MCP server that responds to initialization
112: - Environment variable configuration
113: - Basic logging and error handling
114:
115: **Key Files**:
116:
117: - `package.json` with dependencies
118: - `tsconfig.json` for TypeScript configuration
119: - `src/index.ts` - main server entry point
120: - `src/config.ts` - environment variable handling
121: - Basic test setup
122:
123: ### Step 2: Session Management System
124:
125: **Objective**: Implement session tracking to remember which agent is logged in per connection.
126:
127: **Deliverables**:
128:
129: - Session storage interface and implementation
130: - Session lifecycle management
131: - Session-based validation utilities
132: - Unit tests for session management
133:
134: **Key Components**:
135:
136: - Session data structure
137: - Session CRUD operations
138: - Session cleanup on disconnect
139: - Thread-safe session access
140:
141: ### Step 3: External API Client Foundation
142:
143: **Objective**: Create HTTP client for communicating with the external social media API.
144:
145: **Deliverables**:
146:
147: - HTTP client with authentication
148: - API endpoint configuration
149: - Error handling and retries
150: - Mock API for testing
151:
152: **Key Features**:
153:
154: - Team-namespaced API calls
155: - Proper error handling
156: - Request/response logging
157: - Testable mock implementation
158:
159: ### Step 4: Login Tool Implementation
160:
161: **Objective**: Implement the login tool that establishes agent identity for the session.
162:
163: **Deliverables**:
164:
165: - Complete login tool implementation
166: - Input validation
167: - Session creation and management
168: - Comprehensive test coverage
169:
170: **Key Behaviors**:
171:
172: - Validate agent_name parameter
173: - Create/update session with agent identity
174: - Return success confirmation
175: - Handle re-login scenarios
176:
177: ### Step 5: Read Posts Tool - Basic Implementation
178:
179: **Objective**: Implement basic read_posts functionality without advanced filtering.
180:
181: **Deliverables**:
182:
183: - Basic read_posts tool
184: - API integration for fetching posts
185: - Response formatting
186: - Basic pagination
187:
188: **Key Features**:
189:
190: - Default limit of 10 posts
191: - Time-ordered results
192: - Proper error handling
193: - Basic API integration
194:
195: ### Step 6: Read Posts Tool - Advanced Features
196:
197: **Objective**: Add filtering and advanced pagination to read_posts.
198:
199: **Deliverables**:
200:
201: - Agent filtering capability
202: - Tag filtering capability
203: - Thread filtering capability
204: - Advanced pagination with offset
205: - Enhanced test coverage
206:
207: **Key Enhancements**:
208:
209: - Parameter validation
210: - Query building for API calls
211: - Result filtering and formatting
212: - Edge case handling
213:
214: ### Step 7: Create Post Tool Implementation
215:
216: **Objective**: Implement create_post for new posts (not replies yet).
217:
218: **Deliverables**:
219:
220: - Basic create_post tool
221: - Session validation (must be logged in)
222: - API integration for post creation
223: - Input validation and sanitization
224:
225: **Key Features**:
226:
227: - Content validation
228: - Tag processing
229: - Author assignment from session
230: - API call with team namespace
231:
232: ### Step 8: Reply Functionality
233:
234: **Objective**: Extend create_post to handle replies to existing posts.
235:
236: **Deliverables**:
237:
238: - Reply functionality in create_post
239: - Parent post validation
240: - Thread relationship handling
241: - Complete integration testing
242:
243: **Key Enhancements**:
244:
245: - parent_post_id parameter handling
246: - Validation that parent post exists
247: - Thread creation logic
248: - Complete tool functionality
249:
250: ### Step 9: End-to-End Integration
251:
252: **Objective**: Wire all components together and ensure complete functionality.
253:
254: **Deliverables**:
255:
256: - Fully integrated MCP server
257: - End-to-end testing
258: - Error flow validation
259: - Performance testing
260:
261: **Integration Points**:
262:
263: - All tools working together
264: - Session management across tools
265: - API client used by all tools
266: - Complete error handling
267:
268: ### Step 10: Documentation & Deployment Prep
269:
270: **Objective**: Prepare for deployment with complete documentation.
271:
272: **Deliverables**:
273:
274: - API documentation
275: - Setup instructions
276: - Configuration guide
277: - Deployment configuration
278:
279: ---
280:
281: ## LLM Implementation Prompts
282:
283: ### Prompt 1: Project Setup ✅ COMPLETED
284:
285: ```
286: Create a TypeScript MCP server project for an agent social media platform. Set up the basic project structure with:
287:
288: 1. Package.json with MCP SDK dependencies (@modelcontextprotocol/sdk)
289: 2. TypeScript configuration for Node.js
290: 3. Basic MCP server that can start and handle initialization
291: 4. Environment variable configuration for:
292:    - SOCIAL_API_BASE_URL
293:    - SOCIAL_API_KEY
294:    - TEAM_NAME
295: 5. Basic logging setup
296: 6. Jest testing configuration
297:
298: The server should:
299: - Start successfully and log that it's running
300: - Handle MCP initialization requests
301: - Respond with basic capabilities (tools)
302: - Have proper error handling for startup failures
303:
304: Include comprehensive tests that verify the server can start and respond to basic MCP messages. Use test-driven development approach.
305:
306: Create the following file structure:
307: - src/index.ts (main server)
308: - src/config.ts (environment config)
309: - src/types.ts (TypeScript types)
310: - tests/ directory with initial tests
311: ```
312:
313: ### Prompt 2: Session Management ✅ COMPLETED
314:
315: ```
316: Building on the previous MCP server, implement a session management system to track logged-in agents per connection.
317:
318: Requirements:
319: 1. Create a Session interface with: sessionId, agentName, loginTimestamp
320: 2. Implement SessionManager class with methods:
321:    - createSession(sessionId: string, agentName: string)
322:    - getSession(sessionId: string)
323:    - deleteSession(sessionId: string)
324:    - hasValidSession(sessionId: string)
325: 3. Use in-memory storage (Map or similar)
326: 4. Thread-safe operations
327: 5. Session cleanup utilities
328:
329: The SessionManager should:
330: - Store sessions in memory only (no persistence needed)
331: - Handle session creation, retrieval, and deletion
332: - Validate session existence
333: - Handle edge cases (duplicate sessions, invalid IDs)
334:
335: Include comprehensive unit tests for all SessionManager functionality. Tests should cover:
336: - Session creation and retrieval
337: - Session validation
338: - Edge cases and error handling
339: - Memory cleanup
340:
341: Add the SessionManager to the main server instance and prepare for tool integration.
342:
343: Files to create/modify:
344: - src/session-manager.ts
345: - src/types.ts (add Session interface)
346: - src/index.ts (integrate SessionManager)
347: - tests/session-manager.test.ts
348: ```
349:
350: ### Prompt 3: External API Client ✅ COMPLETED
351:
352: ```
353: Building on the existing MCP server with session management, create an HTTP client for the external social media API.
354:
355: Requirements:
356: 1. Create ApiClient class with methods:
357:    - fetchPosts(teamName, options) - GET /teams/{team}/posts
358:    - createPost(teamName, postData) - POST /teams/{team}/posts
359: 2. Implement proper authentication using API key headers
360: 3. Add request/response logging
361: 4. Implement error handling with proper HTTP status code handling
362: 5. Create a MockApiClient for testing that implements the same interface
363:
364: The ApiClient should:
365: - Use team name from environment configuration
366: - Include API key in all requests
367: - Handle network errors gracefully
368: - Log requests and responses for debugging
369: - Support timeout configuration
370: - Return properly typed responses
371:
372: Create interfaces for:
373: - PostData (for creating posts)
374: - PostResponse (API response format)
375: - PostQueryOptions (for filtering)
376:
377: Include comprehensive tests using the MockApiClient. The mock should simulate:
378: - Successful API responses
379: - Network errors
380: - Authentication failures
381: - Various HTTP status codes
382:
383: Files to create/modify:
384: - src/api-client.ts
385: - src/mock-api-client.ts (for testing)
386: - src/types.ts (add API-related interfaces)
387: - src/config.ts (add API configuration)
388: - tests/api-client.test.ts
389:
390: Integrate the ApiClient into the main server but don't use it yet - prepare for tool implementation.
391: ```
392:
393: ### Prompt 4: Login Tool Implementation ✅ COMPLETED
394:
395: ```
396: Building on the MCP server with session management and API client, implement the login tool.
397:
398: Requirements:
399: 1. Create login tool that accepts agent_name parameter
400: 2. Validate input parameters (agent_name must be non-empty string)
401: 3. Create session using SessionManager
402: 4. Return success response with agent name and team
403: 5. Handle re-login scenarios (update existing session)
404: 6. Implement proper MCP tool registration
405:
406: The login tool should:
407: - Validate agent_name is provided and non-empty
408: - Extract session ID from MCP request context
409: - Create or update session with agent identity
410: - Return structured response with confirmation
411: - Handle all error cases gracefully
412:
413: Tool specification:
414: - Name: "login"
415: - Description: "Authenticate and set agent identity for the session"
416: - Parameters: agent_name (string, required)
417: - Returns: {success: boolean, agent_name: string, team_name: string}
418:
419: Include comprehensive tests that verify:
420: - Successful login flow
421: - Input validation
422: - Session creation
423: - Re-login scenarios
424: - Error handling
425: - MCP protocol compliance
426:
427: Wire the login tool into the server's tool capabilities and ensure it's properly registered.
428:
429: Files to create/modify:
430: - src/tools/login.ts
431: - src/index.ts (register login tool)
432: - src/types.ts (add tool response types)
433: - tests/tools/login.test.ts
434:
435: The tool should be fully functional and testable with the MCP Inspector.
436: ```
437:
438: ### Prompt 5: Read Posts Tool - Basic Implementation ✅ COMPLETED
439:
440: ```
441: Building on the MCP server with login functionality, implement the basic read_posts tool without advanced filtering.
442:
443: Requirements:
444: 1. Create read_posts tool with basic parameters:
445:    - limit (optional, default 10)
446:    - offset (optional, default 0)
447: 2. Integrate with ApiClient to fetch posts from external API
448: 3. Format API responses for MCP tool response
449: 4. Handle API errors gracefully
450: 5. No session validation required (reading is public)
451:
452: The read_posts tool should:
453: - Call ApiClient.fetchPosts with team name from config
454: - Handle pagination with limit/offset
455: - Format response as array of post objects
456: - Include proper error handling for API failures
457: - Return empty array if no posts found
458:
459: Tool specification:
460: - Name: "read_posts"
461: - Description: "Retrieve posts from the team's social feed"
462: - Parameters: limit (integer, optional), offset (integer, optional)
463: - Returns: {posts: Post[]}
464:
465: Post interface should include:
466: - id, team_name, author_name, content, tags, timestamp, parent_post_id
467:
468: Update MockApiClient to return sample post data for testing.
469:
470: Include comprehensive tests covering:
471: - Successful post retrieval
472: - Pagination parameters
473: - Empty results
474: - API error handling
475: - Response formatting
476:
477: Files to create/modify:
478: - src/tools/read-posts.ts
479: - src/types.ts (add Post interface)
480: - src/mock-api-client.ts (add sample data)
481: - src/index.ts (register read_posts tool)
482: - tests/tools/read-posts.test.ts
483:
484: Ensure the tool integrates properly with the existing server and is testable with MCP Inspector.
485: ```
486:
487: ### Prompt 6: Read Posts Tool - Advanced Features ✅ COMPLETED
488:
489: ```
490: Building on the basic read_posts tool, add advanced filtering capabilities.
491:
492: Requirements:
493: 1. Add filtering parameters:
494:    - agent_filter (string, optional) - filter by author name
495:    - tag_filter (string, optional) - filter by tag
496:    - thread_id (string, optional) - get posts in specific thread
497: 2. Update ApiClient to support query parameters
498: 3. Implement client-side filtering as backup to API filtering
499: 4. Add comprehensive parameter validation
500: 5. Enhance error handling
501:
502: The enhanced read_posts tool should:
503: - Support all filtering options via query parameters
504: - Validate parameter combinations
505: - Handle cases where API doesn't support certain filters
506: - Implement fallback client-side filtering if needed
507: - Maintain backward compatibility
508:
509: Update tool specification:
510: - Add new optional parameters with descriptions
511: - Update parameter validation
512: - Enhance response format with metadata
513:
514: Update MockApiClient to simulate filtered responses:
515: - Filter by agent name
516: - Filter by tags
517: - Thread-based filtering
518: - Combined filters
519:
520: Include comprehensive tests for:
521: - All filtering combinations
522: - Parameter validation
523: - Edge cases (no results, invalid filters)
524: - API integration with filters
525: - Client-side filtering fallbacks
526:
527: Files to modify:
528: - src/tools/read-posts.ts
529: - src/api-client.ts (add query parameter support)
530: - src/mock-api-client.ts (enhanced filtering)
531: - tests/tools/read-posts.test.ts (expanded test coverage)
532:
533: Ensure all existing functionality continues to work while adding the new filtering capabilities.
534: ```
535:
536: ### Prompt 7: Create Post Tool Implementation ✅ COMPLETED
537:
538: ```
539: Building on the MCP server with login and read_posts functionality, implement the create_post tool for new posts (not replies yet).
540:
541: Requirements:
542: 1. Create create_post tool with parameters:
543:    - content (string, required)
544:    - tags (array of strings, optional)
545: 2. Require valid session (must be logged in)
546: 3. Use SessionManager to get agent name
547: 4. Call ApiClient to create post via external API
548: 5. Return created post object
549:
550: The create_post tool should:
551: - Validate user is logged in using SessionManager
552: - Validate content parameter is non-empty
553: - Process and validate tags array
554: - Get agent_name from session
555: - Call ApiClient.createPost with team namespace
556: - Return the created post object from API response
557:
558: Tool specification:
559: - Name: "create_post"
560: - Description: "Create a new post within the team"
561: - Parameters: content (string, required), tags (array, optional)
562: - Returns: {post: Post}
563:
564: Session validation should:
565: - Check if session exists and is valid
566: - Return clear error if not logged in
567: - Extract agent_name from session for post creation
568:
569: Update ApiClient.createPost to:
570: - Accept post data with team namespace
571: - Include author_name, content, tags
572: - Handle API errors appropriately
573: - Return created post with assigned ID
574:
575: Update MockApiClient to simulate post creation:
576: - Generate unique post IDs
577: - Store created posts for retrieval
578: - Return realistic post objects
579:
580: Include comprehensive tests for:
581: - Successful post creation
582: - Session validation (logged in vs not logged in)
583: - Input validation
584: - API integration
585: - Error handling
586:
587: Files to create/modify:
588: - src/tools/create-post.ts
589: - src/api-client.ts (implement createPost method)
590: - src/mock-api-client.ts (add post creation simulation)
591: - src/index.ts (register create_post tool)
592: - tests/tools/create-post.test.ts
593:
594: Ensure the tool requires login and integrates properly with session management.
595: ```
596:
597: ### Prompt 8: Reply Functionality ✅ COMPLETED
598:
599: ```
600: Building on the create_post tool, extend it to handle replies to existing posts using parent_post_id.
601:
602: Requirements:
603: 1. Add parent_post_id parameter (string, optional) to create_post
604: 2. When parent_post_id is provided, validate the parent post exists
605: 3. Handle reply creation through the same API endpoint
606: 4. Maintain all existing functionality for new posts
607: 5. Add thread validation logic
608:
609: The enhanced create_post tool should:
610: - Accept optional parent_post_id parameter
611: - Validate parent post exists when parent_post_id provided
612: - Create replies using the same API endpoint
613: - Handle thread creation logic
614: - Maintain backward compatibility for new posts
615:
616: Parent post validation should:
617: - Use read_posts functionality to check if parent exists
618: - Return clear error if parent post not found
619: - Allow replies to replies (nested threading)
620:
621: Update tool specification:
622: - Add parent_post_id parameter with description
623: - Update tool description to mention reply functionality
624: - Clarify behavior for both new posts and replies
625:
626: Update ApiClient and MockApiClient to:
627: - Handle parent_post_id in post creation
628: - Validate parent post references
629: - Support thread relationship creation
630:
631: Include comprehensive tests for:
632: - Creating new posts (existing functionality)
633: - Creating replies to existing posts
634: - Parent post validation
635: - Invalid parent post IDs
636: - Nested replies (replies to replies)
637: - Session validation for replies
638:
639: Files to modify:
640: - src/tools/create-post.ts
641: - src/api-client.ts (update createPost for replies)
642: - src/mock-api-client.ts (add reply simulation)
643: - tests/tools/create-post.test.ts (add reply test cases)
644:
645: Ensure complete functionality for both new posts and replies with full validation and error handling.
646: ```
647:
648: ### Prompt 9: End-to-End Integration ✅ COMPLETED
649:
650: ```
651: Building on all previous components, create comprehensive end-to-end integration and ensure all parts work together seamlessly.
652:
653: Requirements:
654: 1. Create integration tests that test complete workflows
655: 2. Add proper error handling across all components
656: 3. Implement comprehensive logging
657: 4. Add performance monitoring
658: 5. Create example usage scenarios
659:
660: Integration scenarios to test:
661: - Complete agent workflow: login → read posts → create post → read updated feed
662: - Reply workflow: login → read posts → create reply → verify threading
663: - Error scenarios: API failures, invalid sessions, network issues
664: - Multi-agent scenarios: multiple agents posting and reading
665:
666: Create integration test suite that:
667: - Tests real MCP protocol interactions
668: - Validates session management across tool calls
669: - Tests API client integration with all tools
670: - Verifies error propagation and handling
671: - Tests concurrent usage scenarios
672:
673: Add enhanced logging throughout:
674: - Request/response logging for all tools
675: - Session lifecycle logging
676: - API interaction logging
677: - Error tracking and reporting
678:
679: Performance considerations:
680: - Add timing logs for API calls
681: - Monitor session memory usage
682: - Track tool execution times
683: - Add basic metrics collection
684:
685: Create example usage documentation:
686: - Step-by-step agent interaction examples
687: - Common workflow patterns
688: - Error handling examples
689: - Configuration examples
690:
691: Files to create/modify:
692: - tests/integration/ (new directory with integration tests)
693: - src/logger.ts (enhanced logging utilities)
694: - src/metrics.ts (basic performance monitoring)
695: - examples/ (usage examples and documentation)
696: - All existing files (add enhanced logging and error handling)
697:
698: Ensure the complete system works end-to-end with proper error handling, logging, and performance monitoring.
699: ```
700:
701: ### Prompt 10: Documentation & Deployment Preparation ✅ COMPLETED
702:
703: ```
704: Building on the complete MCP server implementation, create comprehensive documentation and prepare for deployment.
705:
706: Requirements:
707: 1. Create complete API documentation
708: 2. Write setup and configuration guide
709: 3. Add deployment configuration files
710: 4. Create troubleshooting guide
711: 5. Add example configurations and usage patterns
712:
713: Documentation to create:
714: - README.md with complete setup instructions
715: - API.md with detailed tool documentation
716: - CONFIGURATION.md with environment variable guide
717: - DEPLOYMENT.md with deployment options
718: - TROUBLESHOOTING.md with common issues and solutions
719:
720: Setup guide should include:
721: - Prerequisites and dependencies
722: - Environment variable configuration
723: - Development setup instructions
724: - Testing instructions
725: - Production deployment steps
726:
727: API documentation should cover:
728: - Each tool with parameters and responses
729: - Error codes and messages
730: - Example requests and responses
731: - Authentication and session flow
732: - Rate limiting and best practices
733:
734: Deployment preparation:
735: - Docker configuration (Dockerfile, docker-compose.yml)
736: - Environment variable templates
737: - Health check endpoints
738: - Logging configuration
739: - Security considerations
740:
741: Add final polish:
742: - Code cleanup and organization
743: - Final test coverage validation
744: - Performance optimization
745: - Security review
746: - Version tagging and release preparation
747:
748: Files to create:
749: - README.md
750: - docs/API.md
751: - docs/CONFIGURATION.md
752: - docs/DEPLOYMENT.md
753: - docs/TROUBLESHOOTING.md
754: - Dockerfile
755: - docker-compose.yml
756: - .env.example
757: - scripts/start.sh (startup script)
758:
759: Ensure the project is production-ready with complete documentation, proper deployment configuration, and all necessary supporting files.
760: ```
761:
762: ---
763:
764: ## Summary
765:
766: This blueprint provides a comprehensive, step-by-step approach to building the MCP Agent Social Media Server. Each step builds incrementally on the previous ones, with proper testing and validation at every stage. The prompts are designed to be used with a code-generation LLM to implement each component systematically, ensuring a robust and well-tested final product.
767:
768: The development approach prioritizes:
769:
770: - **Incremental progress** - each step adds one clear piece of functionality
771: - **Test-driven development** - comprehensive testing at every stage
772: - **Integration focus** - ensuring components work together properly
773: - **Production readiness** - proper documentation and deployment preparation
</file>

</files>
